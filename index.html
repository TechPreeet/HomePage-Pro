<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"/>

  
      <!-- ── INSERT HERE ── -->
        <script>
          
    /* ----- Search Bar Fixes ----- */
    const originalPerformSearch = window.performSearch;
    window.performSearch = function () {
        // Clear search UI so cross icon disappears
        const input = document.getElementById('searchInput');
        const clearIcon = document.getElementById('clearIcon');
        if (input) input.value = '';
        if (clearIcon) clearIcon.style.display = 'none';
        if (typeof handleSearchInput === 'function') handleSearchInput();

        return originalPerformSearch.apply(this, arguments);
    };

    /* ----- Voice Search fix for New‑Tab setting ----- */
    if (typeof startVoiceSearch === 'function') {
        const originalStartVoice = startVoiceSearch;
        window.startVoiceSearch = function () {
            // Wrap original function
            originalStartVoice.apply(this, arguments);

            // When recognition ends, force a performSearch()
            if (window.recognition) {
                recognition.addEventListener('result', () => {
                    setTimeout(() => {
                        performSearch();
                    }, 200);
                }, { once: true });
            }
        };
    }

    /* ----- Remove lingering active styles on touch devices ----- */
    document.addEventListener('touchend', () => {
        document.querySelectorAll('.tile').forEach(el => el.classList.remove('active'));
    });


</script>
        <!-- ── END INSERT ── -->


  <title>HomePage Pro</title>

  <!-- iPhone 15 Pro Max (428×926 @3x) -->
<link rel="apple-touch-startup-image"
      href="/splash/iphone-15-pro-max.png"
      media="(device-width: 428px) and (device-height: 926px)
             and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">

<!-- repeat for landscape orientations if you care -->

<link rel="manifest" href="manifest.json">

<meta name="theme-color" content="#050f26">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport"
  content="width=device-width,
           initial-scale=1.0,
           maximum-scale=1.0,
           user-scalable=no,
           viewport-fit=cover"
/>

<link rel="icon" href="icons/icon-72.png" sizes="72x72" type="image/png">
<link rel="icon" href="icons/icon-96.png" sizes="96x96" type="image/png">
<link rel="icon" href="icons/icon-128.png" sizes="128x128" type="image/png">
<link rel="icon" href="icons/icon-144.png" sizes="144x144" type="image/png">
<link rel="icon" href="icons/icon-152.png" sizes="152x152" type="image/png">
<link rel="icon" href="icons/icon-192.png" sizes="192x192" type="image/png">
<link rel="icon" href="icons/icon-384.png" sizes="384x384" type="image/png">
<link rel="icon" href="icons/icon-512.png" sizes="512x512" type="image/png">

<link rel="apple-touch-icon" href="icons/icon-120.png" sizes="120x120">
<link rel="apple-touch-icon" href="icons/icon-152.png" sizes="152x152">
<link rel="apple-touch-icon" href="icons/icon-167.png" sizes="167x167">
<link rel="apple-touch-icon" href="icons/icon-180.png" sizes="180x180">


  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <style>
    :root {
      --accent-color: #007bff;
      --bg-color: white;
      --text-color: #000000;
      --grid-gap: 20px;
    }

    html, body {
      pointer-events: auto !important;
    }

    /* Push your app’s content into the safe‑area edges */
    #app, /* or whatever your top‑level container is called */
    main {
      padding-top:    env(safe-area-inset-top);
      padding-right:  env(safe-area-inset-right);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left:   env(safe-area-inset-left);

      /* for older Safari: */
      padding-top:    constant(safe-area-inset-top);
      padding-right:  constant(safe-area-inset-right);
      padding-bottom: constant(safe-area-inset-bottom);
      padding-left:   constant(safe-area-inset-left);
    }

    html, body {
      height: 100vh;
      width: 100vw;
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      overflow: hidden;
      transition: background-color 0.5s ease-in-out;
    }
    body.dark-mode {
        background-color: #121212;
    }
    /* Make your wallpaper fill edge‑to‑edge */
    body {
      background-repeat:   no-repeat;
      background-size:     cover;
      background-position: center center;
    }

    body:focus {
        outline: none;
    }

    .hidden {
      display: none;
    }

    @keyframes tileFadeIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    /* FIX: Apply animation only when not in rearrange mode */
    #bookmarkGrid:not(.rearrange-active):not(.no-animation) .tile {
        animation: tileFadeIn 0.2s ease-out forwards;
        opacity: 0; /* Make invisible only for the animation */
    }

    .tile.dragging {
      opacity: 0.5;
      transform: scale(0.95);
      transition: transform 0.1s ease, opacity 0.1s ease;
      z-index: 10;
    }

    .tile:not(.add-tile):hover, .tile:focus-visible {
      transform: scale(1.1);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.3);
      background: linear-gradient(135deg, rgba(0, 123, 255, 0.2), var(--accent-color));
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    .tile:not(.add-tile):hover .bookmark-label {
      transform: scale(1.05);
      transition: transform 0.2s ease;
    }

    @media (hover: none) and (pointer: coarse) {
      .tile:not(.add-tile):active {
        transform: scale(1.1);
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.3);
        background: linear-gradient(135deg, rgba(0, 123, 255, 0.2), rgba(0, 123, 255, 0.4));
      }
    }

    body.glass-mode .tile,
    body.glass-mode .search-bar-form {
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.15);
      backdrop-filter: blur(6px) saturate(120%);
      background: rgba(255, 255, 255, 0.12);
      color: var(--text-color);
      transform: translateZ(0);
      will-change: transform, opacity;
    }

    body.dark-mode.glass-mode .tile,
    body.dark-mode.glass-mode .search-bar-form {
      background: rgba(30, 30, 30, 0.3);
      border-color: rgba(100, 100, 100, 0.3);
    }

    @media (max-width: 768px) {
    body.glass-mode .tile,
    body.glass-mode .search-bar-form {
      backdrop-filter: none;
      background: rgba(255, 255, 255, 0.1);
      }
    }
    @media (hover: hover) and (pointer: fine) {
      body.glass-mode .tile:hover,
      body.glass-mode .search-bar-form:hover {
      transform: scale(1.05);
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
      }
    }

    .search-bar-form {
      width: 85%;
      max-width: 550px;
      display: flex;
      align-items: center;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(2.5px);
      border-radius: 24px;
      padding: 10px 15px;
      margin-bottom: 20px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: box-shadow 0.3s ease;
      position: sticky;
      top: 20px;
      z-index: 100;
    }

    body.dark-mode .search-bar-form {
      color: var(--icon-color-dark, #ddd);
      background: rgba(30, 30, 30, 0.3);
    }

    .search-bar-form:hover {
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.2);
    }

    .search-bar-form input {
      flex: 1;
      background: transparent;
      border: none;
      color: var(--text-color);
      font-size: 16px;
      outline: none;
    }

    .search-bar-form input::placeholder {
        color: var(--text-color);
        opacity: 0.7;
    }

    .search-bar-form svg, .search-bar-form .material-icons {
      margin-left: 10px;
      cursor: pointer;
      color: var(--text-color);
      transition: color 0.3s ease;
    }

    .search-bar-form svg:hover, .search-bar-form .material-icons:hover {
      color: var(--accent-color);
    }

    .tile {
      width: 90px;
      text-align: center;
      color: var(--text-color);
      text-decoration: none;
      font-size: 13px;
      position: relative;
      margin-left: 6px;
      margin-right: 6px;
      box-sizing: border-box;
      z-index: 1;
      word-break: break-word;
      max-height: 120px;
      overflow: hidden;
      border-radius: 16px;
      -webkit-touch-callout: none;
    }

    .tile img {
      width: 80%;
      height: 80%;
      border-radius: 50%;
    }

    .tile.xsmall img {
      width: 40px;
      height: 40px;
    }

    .tile.xsmall {
      font-size: 9px;
      width: 50px;
    }

    .tile.img {
      width: 80px;
      height: 80px;
      border-radius: 16px;
      background: #ccc;
    }

    @media (max-width: 600px) {
      .tile img {
        width: 60px;
        height: 60px;
      }

      .tile {
        width: 70px;
        font-size: 11px;
      }

      .tile.xsmall img {
        width: 30px;
        height: 30px;
      }

      .tile.xsmall {
        width: 40px;
      }

      .grid {
        justify-content: center;
      }
    }

    @media (min-width: 1200px) {
      .tile img {
        width: 100px;
        height: 100px;
      }

      .tile {
        width: 110px;
        font-size: 14px;
      }

      .tile.xsmall img {
        width: 50px;
        height: 50px;
      }

      .tile.xsmall {
        width: 60px;
        margin: 2px 0;
      }

      .tile.small img {
        width: 50px;
        height: 50px;
      }

      .tile.small {
        font-size: 11px;
        width: 60px;
        margin: 4px 0;
      }

      :root {
        --grid-gap: 10px;
      }
    }

    .tile.small img {
      width: 50px;
      height: 50px;
    }

    .tile.small {
      font-size: 11px;
      width: 60px;
    }

    .tile.medium img {
      width: 80px;
      height: 80px;
    }

    .tile.medium {
      font-size: 13px;
      width: 90px;
    }

    .tile.large img {
      width: 100px;
      height: 100px;
    }

    .tile.large {
      font-size: 15px;
      width: 110px;
    }

    .hide-labels .bookmark-label {
      opacity:0; visibility:hidden;    
    }

    .bookmark-label {
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      text-align: center;
      padding: 4px 0;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 1.2;
      max-height: calc(1.2em * 2);
    }

    .tile .menu {
      position: absolute;
      top: 0;
      right: 0;
      cursor: pointer;
      font-weight: bold;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      border-radius: 5px;
      padding: 2px 6px;
      z-index: 11;
      display: none;
    }

    @media (hover: hover) and (pointer: fine) {
      .tile:hover .menu {
        display: block;
      }
    }

    .floating-menu {
      position: fixed;
      background: rgba(0, 0, 0, 0.95);
      border-radius: 8px;
      padding: 6px 0;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      color: white;
      font-size: 13px;
      line-height: 1.4;
      z-index: 999999;
      overflow-y: auto;
      max-height: 200px;
      min-width: 140px;
    }

    .floating-menu div {
      padding: 6px 10px;
      cursor: pointer;
      white-space: nowrap;
    }

    .floating-menu div:hover {
      background: var(--accent-color);
    }
    .tile {
      position: relative;
      overflow: visible !important;
    }

    .tile img.round {
      border-radius: 50%;
    }

    .tile img.squircle {
      border-radius: 20%;
    }

    .tile img.rounded-rect {
      border-radius: 30%;
    }

    .tile img.tv-rect { 
      clip-path: inset(11% 0 11% 0 round 12px) !important;
      border-radius: 0 !important;  
    }

    .tile img.sammy {
        border-radius: 65% / 90%;
    }


    #sidebar-toggle-btn {
        position: fixed;
        top: calc(15px + env(safe-area-inset-top));
        right: calc(15px + env(safe-area-inset-right));
        width: 40px;
        height: 40px;
        background: transparent;
        backdrop-filter: none;
        border-radius: 50%;
        cursor: pointer;
        z-index: 1002;
        display: flex;
        align-items: center;
        justify-content: center;
        border: none;
        transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        outline: none;
    }

    /* FIX: Refactored hover/active states for sidebar button */
    #sidebar-toggle-btn:active .hamburger-icon span,
    #sidebar-toggle-btn.active-touch .hamburger-icon span,
    #sidebar-toggle-btn:focus-visible .hamburger-icon span {
        background: var(--accent-color);
    }

    @media (hover: hover) and (pointer: fine) {
        #sidebar-toggle-btn:hover {
            background: rgba(50, 50, 50, 0.2);
        }
        #sidebar-toggle-btn:hover .hamburger-icon span {
            background: var(--accent-color);
        }
    }

    #sidebar-toggle-btn .hamburger-icon {
        width: 24px;
        height: 24px;
        position: relative;
    }
    #sidebar-toggle-btn .hamburger-icon span {
        display: block;
        position: absolute;
        height: 3px;
        width: 100%;
        background: var(--text-color);
        border-radius: 3px;
        opacity: 1;
        left: 0;
        transform: rotate(0deg);
        transition: .25s ease-in-out;
    }
    #sidebar-toggle-btn .hamburger-icon span:nth-child(1) { top: 4px; }
    #sidebar-toggle-btn .hamburger-icon span:nth-child(2) { top: 11px; }
    #sidebar-toggle-btn .hamburger-icon span:nth-child(3) { top: 18px; }

    #sidebar-toggle-btn.open {
        transform: rotate(180deg);
    }
    #sidebar-toggle-btn.open .hamburger-icon span:nth-child(1) {
        top: 11px;
        transform: rotate(135deg);
    }
    #sidebar-toggle-btn.open .hamburger-icon span:nth-child(2) {
        opacity: 0;
        left: -24px;
    }
    #sidebar-toggle-btn.open .hamburger-icon span:nth-child(3) {
        top: 11px;
        transform: rotate(-135deg);
    }
    
    #settings-sidebar {
      position: fixed;
      top: 0;
      right: 0;
      width: 300px;
      max-width: 85vw;
      height: 100%;
      background: rgba(30, 30, 30, 0.8);
      backdrop-filter: blur(15px);
      color: white;
      z-index: 1001;
      box-shadow: -5px 0 25px rgba(0, 0, 0, 0.4);
      transform: translateX(100%);
      transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.3s ease;
      overflow-y: auto;
      padding: 20px;
      padding-top: calc(20px + env(safe-area-inset-top));
      padding-bottom: calc(20px + env(safe-area-inset-bottom));
      box-sizing: border-box;
    }
    #settings-sidebar.open {
      transform: translateX(0);
    }
    
    #sidebar-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.4s ease;
        pointer-events: none;
    }
    #sidebar-overlay.open {
        opacity: 1;
        pointer-events: auto;
    }

    #sidebar-profile-section {
      padding: 15px;
      margin-bottom: 20px;
      text-align: center;
      border-left: 3px solid var(--accent-color);
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      font-family: 'Georgia', serif;
    }

    #sidebar-greeting {
      font-size: 18px;
      font-weight: 500;
      margin-right: 20px;
      margin-bottom: 12px;
      color: var(--accent-color);
    }

    #sidebar-clock {
      font-size: 32px;
      font-weight: 600;
      text-shadow: 0 0 8px rgba(0,0,0,0.5);
    }

    #sidebar-clock .ampm {
        font-size: 50%;
        vertical-align: super;
        margin-left: 4px;
    }

    #sidebar-date {
      font-size: 14px;
      opacity: 0.9;
      margin-top: 6px;
    }

    #sidebar-weatherContainer {
        font-size: 16px;
        margin-top: 10px;
        opacity: 0.9;
    }

    .toolbar-option {
      margin: 10px 0;
      cursor: pointer;
      white-space: nowrap;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s ease;
      border-radius: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px; /* adjust for your spacing */
    }

    .toolbar-option-header {
      font-weight: 700;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      padding-bottom: 8px;
      margin-top: 15px;
    }

    .toolbar-option-header::after {
        content: ' ▾';
        float: right;
        margin-left: auto;
        transition: transform 0.3s ease-in-out;
    }

    .toolbar-option-header.open::after {
        transform: rotate(180deg);
    }

    .collapsible-content {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.4s ease-in-out;
        padding-left: 10px;
    }

    .collapsible-content.open {
        max-height: 500px;
    }

    .search-engine-icon {
        width: 20px;
        height: 20px;
        margin-right: 10px;
        border-radius: 4px;
    }

    #currentSearchEngine {
        display: flex;
        align-items: center;
        width: 100%;
    }

    #accentColorOption {
        justify-content: space-between;
    }
    #accentColorPicker {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        width: 40px;
        height: 25px;
        background-color: transparent;
        border: none;
        cursor: pointer;
    }
    #accentColorPicker::-webkit-color-swatch {
        border-radius: 5px;
        border: 1px solid rgba(255, 255, 255, 0.3);
    }
    #accentColorPicker::-moz-color-swatch {
        border-radius: 5px;
        border: 1px solid rgba(255, 255, 255, 0.3);
    }

    /* place in your <style> below the .toolbar-option rules */
.toolbar-option.search-engine-option {
  justify-content: flex-start;  /* left‑align contents */
}
.search-engine-option .search-engine-icon {
  margin-right: 0.25em;         /* ~ single‑letter space */
  width: 20px; height: 20px;    /* match your sizing */
}



    .toolbar-option:hover {
      background: var(--accent-color);
      transform: scale(1.02);
      box-shadow: 0 0 15px -2px var(--accent-color);
    }
    
    /* ===== Range‑slider track & thumb (all three sliders) ===== */
#tileSizeSlider,
#gradientSlider,
#iconStyleSlider{
  width: 90%;
  margin: 5px 0;
  -webkit-appearance: none;
          appearance: none;
  height: 8px;
  border-radius: 50px;               /* pill shape – round on all edges   */
  background: #ffffff;               /* plain; JS will paint the gradient */
  outline: none;
  transition: opacity .3s ease;
}

/* Chrome / Safari / Edge track */
#tileSizeSlider::-webkit-slider-runnable-track,
#gradientSlider::-webkit-slider-runnable-track,
#iconStyleSlider::-webkit-slider-runnable-track{
  height: 8px;
  border-radius: 50px;
  background: transparent;           /* let the main rule show through    */
}

/* Firefox track */
#tileSizeSlider::-moz-range-track,
#gradientSlider::-moz-range-track,
#iconStyleSlider::-moz-range-track{
  height: 8px;
  border-radius: 50px;
  background: transparent;
}


    #tileSizeSlider::-webkit-slider-thumb, #gradientSlider::-webkit-slider-thumb, #iconStyleSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #ffffff;
      border-radius: 50%;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      cursor: pointer;
      transition: transform 0.2s ease;
      margin-top: -4px;          /* (thumb‑height – track‑height)/2 */
    }

    #tileSizeSlider::-webkit-slider-thumb:hover, #gradientSlider::-webkit-slider-thumb:hover, #iconStyleSlider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    #tileSizeSlider::-moz-range-thumb, #gradientSlider::-moz-range-thumb, #iconStyleSlider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #ffffff;
      border-radius: 50%;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      cursor: pointer;
      transition: transform 0.2s ease;
      margin-top: -4px;          /* (thumb‑height – track‑height)/2 */
    }

    #tileSizeSlider::-moz-range-thumb:hover, #gradientSlider::-moz-range-thumb:hover, #iconStyleSlider::-moz-range-thumb:hover {
      transform: scale(1.2);
    }

    #tileSizeSliderContainer, #gradientSliderContainer, #iconStyleSliderContainer {
      margin: 10px 0;
      padding: 0 10px;
    }

    /* When dragging ANY slider, hide every child of the sidebar... */
body.sidebar-slider-active #settings-sidebar > *{
  opacity:0;
  visibility:hidden;
  pointer-events:none;
  transition:opacity .12s, visibility .12s;
}

/* ...EXCEPT the container holding the active slider */
body.sidebar-slider-active #settings-sidebar > .slider-container-active{
  opacity:1 !important;
  visibility:visible !important;
  pointer-events:auto !important;
  position:relative;
  z-index:9999;
}

/* Make sure the sidebar chrome itself doesn’t show */
body.sidebar-slider-active #settings-sidebar{
  background:transparent !important;
  border:none !important;
  box-shadow:none !important;
  backdrop-filter:none !important;
}


    #bgInput, #importInput, #videoInput, #lensInput {
      display: none;
    }

    .rearrange-active .tile {
      cursor: grab;
      transition: transform 0.2s cubic-bezier(0.22, 1, 0.36, 1), box-shadow 0.2s;
      box-shadow: 0 2px 12px rgba(0,123,255,0.15);
    }
    .tile.dragging, .tile.drag-ghost {
      opacity: 0.7;
      transform: scale(1.08) rotate(-2deg);
      z-index: 10;
      box-shadow: 0 8px 32px rgba(0,123,255,0.25);
    }
    .rearrange-active .tile:not(.add-tile):hover {
      transform: scale(1.12);
      box-shadow: 0 8px 24px rgba(0,123,255,0.18);
    }

    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.3s ease;
      pointer-events: none;
      opacity: 0;
    }

    #tabsModal {
        z-index: 1600; /* Higher than iframe viewer */
    }

    .modal.hidden {
      display: none;
    }

    .modal:not(.hidden) {
      pointer-events: auto;
      opacity: 1;
    }

    .modal-content {
      background: rgba(30, 30, 30, 0.85);
      backdrop-filter: blur(10px);
      color: white;
      padding: 20px;
      border-radius: 10px;
      width: 90%;
      max-width: 400px;
      display: flex;
      flex-direction: column;
      align-items: center;
      transition: transform 0.3s ease, opacity 0.3s ease;
      transform: scale(0.95);
      opacity: 0;
    }

    .modal:not(.hidden) .modal-content {
      transform: scale(1);
      opacity: 1;
    }

    .modal-content input {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      width: 80%;
      margin: 10px 0;
      padding: 8px;
      border-radius: 5px;
    }

    .modal-content button {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      cursor: pointer;
      width: 80%;
      margin: 10px 0;
      padding: 8px;
      border-radius: 5px;
      transition: background 0.2s ease;
    }

    .modal-content button:hover {
      background: var(--accent-color);
    }

    #toast-notification {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 12px 20px;
        border-radius: 25px;
        z-index: 2000;
        opacity: 0;
        transition: opacity 0.3s ease, bottom 0.3s ease;
        pointer-events: none;
    }
    #toast-notification.show {
        opacity: 1;
        bottom: 40px;
        pointer-events: auto;
    }

    .close-icon {
      position: absolute;
      top: 10px;
      right: 16px;
      font-size: 20px;
      color: white;
      cursor: pointer;
      transition: color 0.2s ease;
    }
    
    .close-icon:hover {
        color: var(--accent-color);
    }

    .about-box {
      background: rgba(30, 30, 30, 0.85);
      backdrop-filter: blur(10px);
      padding: 20px;
      border-radius: 16px;
         border: .5px solid var(--accent-color);
      max-width: 90vw;
      width: 75%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      font-family: 'Georgia', serif;
      font-size: 18px;
      line-height: 1.6;
      color: white;
      position: relative;
      animation: fadeIn 0.4s ease;
      box-sizing: border-box;
    }

    .about-box h2 {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 16px;
    }

    .about-box p {
      font-size: 18px;
      margin: 12px 0;
      z-index: 1;
      position: relative;
    }

    .about-box strong {
      font-weight: 600;
    }

    .about-box em {
      font-style: italic;
      color: #cccccc;
    }

    .cta-link {
      font-size: 18px;
      font-weight: bold;
      display: inline-block;
      margin-top: 6px;
      color: var(--accent-color);
      text-decoration: none;
    }

    .cta-link:hover {
      text-decoration: underline;
    }

    .about-box .close-icon {
      font-size: 20px;
      color: white;
      cursor: pointer;
    }

    @keyframes fadeIn {
      from {
        transform: scale(0.95);
        opacity: 0;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    #videoBg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: -1;
      pointer-events: none;
    }

    body.video-active #videoBg {
      z-index: 0;
    }

    body.bg-image-active {
      background-size: cover;
      background-position: center;
      z-index: 1;
    }

    @keyframes spinOnce {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #micIcon.animate-mic {
      animation: spinOnce 1s ease;
    }

    @keyframes wiggle {
      0% { transform: rotate(-1.5deg); }
      50% { transform: rotate(1.5deg); }
      100% { transform: rotate(-1.5deg); }
    }

    .tile.rearrange-wiggle {
      animation: wiggle 0.4s ease-in-out infinite;
    }

    .delete-btn {
      position: absolute;
      top: -6px;
      left: -6px;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background-color: red;
      color: white;
      font-size: 16px;
      font-weight: bold;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.4);
    }
    
    @media (hover: none) and (pointer: coarse) {
    .tile:not(.add-tile):hover {
      transform: none;
      box-shadow: none;
      background: none;
      }
    } 

    input, textarea {
      user-select: text;
      -webkit-user-select: text;
    }
  
      .coin {
      width: 100px;
      height: 100px;
      position: relative;
      margin: 20px auto;
      transform-style: preserve-3d;
      cursor: pointer;
      transform: rotateY(0deg);
      transition: transform 2s ease-in-out;
    }

    .coin div {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      position: absolute;
      backface-visibility: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: bold;
      color: #8b5a2b;
      background: linear-gradient(45deg, #fce5a3, #f3c66b);
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }

    .coin .heads {
      transform: rotateY(0deg) translateZ(1px);
    }
    .coin .tails {
      transform: rotateY(180deg) translateZ(1px);
    }

    body, html, .container {
      user-select: none;
      -webkit-user-select: none;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    #bookmarksWrapper {
      flex: 1 1 auto;
      width: 100%;
      padding-bottom: 4rem;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #bookmarksWrapper .spacer {
        height: 30vh;
        flex-shrink: 0; /* Prevents the spacer from shrinking */
    }

    #bookmarkControls {
      display: flex;
      justify-content: center;
      gap: 1.5rem; /* Closer buttons */
      margin-bottom: 1.5rem;
      width: 100%;
      position: relative;
    }
    
    .toggle-arrow,
    .toggle-add,
    .toggle-refresh {
      position: relative;
      width: 1.75rem;
      height: 1.75rem;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(6px);
      opacity: 0.5;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 40%;
      cursor: pointer;
      color: currentColor;
      font-size: 1rem;
      line-height: 1;
      transition: all 0.2s ease;
      z-index: 20;
    }
    
    .toggle-add {
        font-weight: 900;
    }

    .toggle-refresh {
        font-size: 1.2rem;
        font-weight: 700;
    }

    /* Hover only on desktops (pointer: fine) */
    @media (pointer: fine) {
      .toggle-arrow:hover,
      .toggle-add:hover,
      .toggle-refresh:hover {
        opacity: 1;
        background-color: var(--accent-color);
        transform: scale(1.15);
      }
    }

    /* Remove any touch :active styling so nothing sticks on touch */
    .toggle-arrow:active,
    .toggle-add:active,
    .toggle-refresh:active {
      /* override to no effect on touch */
      background-color: transparent !important;
      opacity: 1 !important;
      transform: none !important;
    }


    #bookmarkGrid {
      display: flex;
      flex-wrap: wrap;
      gap: var(--grid-gap, 20px);
      justify-content: center;
      width: 100%;
      max-width: 1400px;
      padding: 0 1rem 1rem;
      box-sizing: border-box;
      transition: opacity 0.2s ease-out;
      will-change: opacity;
      opacity: 1;
    }

    .collapsed #bookmarkGrid {
      opacity: 0;
      pointer-events: none;
      max-height: 0;
    }

    .collapsed .toggle-arrow {
      transform: rotate(-180deg);
    }

    .collapsed #addBookmarkBtn,
    .collapsed #refreshBtn {
      display: none;
    }
  
    #searchInput::-webkit-search-cancel-button {
      display: none;
    }
    #searchInput::-ms-clear {
      display: none;
    }

    body.glass-mode .tile img {
      margin: 0;                 
      transform: translateY(5px);
    }

    .search-bar-form input,
    .modal-content input,
    .modal-content textarea {
      font-size: 16px !important;
      -webkit-text-size-adjust: 100%;
    }

    *:focus-visible {
        outline: 2px solid var(--accent-color) !important;
        outline-offset: 2px;
        border-radius: 3px;
    }
    
    #searchInput:focus-visible {
      outline: none !important;
    }

    .search-results-container {
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      max-height: 300px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    body.dark-mode .search-results-container {
      background: rgba(30, 30, 30, 0.3); /* Restored original dark mode color */
    }

    .search-result-item {
      display: flex;
      align-items: center;
      padding: 10px;
      cursor: pointer;
      color: white;
      text-decoration: none;
    }

    .search-result-item:hover, .search-result-item:focus-visible {
      background: rgba(255, 255, 255, 0.1);
    }

    .search-result-item img {
      width: 30px;
      height: 30px;
      margin-right: 15px;
      border-radius: 5px;
    }

    /* ─── iOS‑style switch ─── */
.switch {
  position: relative;
  display: inline-block;
  width: 40px;
  height: 20px;
}
.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}
.switch .slider {
  position: absolute;
  cursor: pointer;
  top: 0; left: 0; right: 0; bottom: 0;
  background-color: #ccc;
  transition: .4s;
  border-radius: 34px;
  /* new: white outline */
  border: 1px solid rgb(255, 255, 255);
  box-sizing: border-box;
}
.switch .slider:before {
  position: absolute;
  content: "";
  height: 14px;
  width: 14px;
  left: 2px; bottom: 2px;
  background-color: white;
  transition: .2s;
  border-radius: 50%;
}
/* checked state */
.switch input:checked + .slider {
  background-color: var(--accent-color);
}
.switch input:checked + .slider:before {
  transform: translateX(20px);
}
/* Dark‑Mode switch default (off) = white */
#darkModeSwitch + .slider {
  background-color: #ccc;
}
/* Dark‑Mode switch on = black */
#darkModeSwitch:checked + .slider {
  background-color: black !important;
}

/* colon & AM/PM accent */
#sidebar-clock .colon,
#sidebar-clock .ampm {
  color: var(--accent-color);
}

/* Accent‑color on modal close buttons */
.close-icon:hover {
  color: var(--accent-color);
}

/* 1) Turn off Android’s default blue overlay everywhere */
* {
  -webkit-tap-highlight-color: transparent !important;
  tap-highlight-color: transparent !important;
  }
  /* 2) On touch‑only devices, also strip focus styles so nothing sticks after lift */
  @media (hover: none) and (pointer: coarse) {
    .toolbar-option:focus,
    .tile:focus,
    .toggle-arrow:focus,
    .toggle-add:focus,
    .toggle-refresh:focus,
    .floating-menu div:focus {
      outline: none !important;
      background: none !important;
    }
  }
   /* 3) Only show your accent flash on :active (finger‑down), never on :focus*/
  .toolbar-option:active,
  .tile:active,
  .toggle-arrow:active,
  .toggle-add:active,
  .toggle-refresh:active,
  .floating-menu div:active {
    background: var(--accent-color) !important;
  }

/* ─── Wallpaper blur layer ─── */
#bgBlurLayer {
  position: fixed;
  inset: 0;
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  pointer-events: none;
  z-index: 0;
  opacity: 0;
  transition: opacity .25s ease;
}
body.bg-blur #bgBlurLayer {
  opacity: 1;
}

/* --- iFrame In-App Browser Styles --- */
#iframe-viewer {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1500;
  background-color: var(--bg-color);
  display: flex;
  flex-direction: column;
  transform: translateY(100%);
  transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
}

#iframe-viewer:not(.hidden) {
    transform: translateY(0);
}

#iframe-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px;
  background-color: var(--accent-color);
  flex-shrink: 0;
  height: 45px;
  box-sizing: border-box;
  color: white;
}

#iframe-tab-info {
  display: flex;
  align-items: center;
  overflow: hidden;
  color: white;
}

#iframe-favicon {
  width: 20px;
  height: 20px;
  margin-right: 10px;
}

#iframe-title {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

#iframe-buttons {
    display: flex;
    align-items: center;
}

#iframe-buttons button {
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  padding: 5px;
  border-radius: 5px;
  transition: background-color 0.2s ease;
  width: 32px;
  height: 32px;
  display: flex;
  justify-content: center;
  align-items: center;
}

#iframe-buttons button:hover {
  background-color: rgba(255, 255, 255, 0.2);
}

#iframe-buttons button svg {
    width: 20px;
    height: 20px;
}

#browser-frame {
  width: 100%;
  height: 100%;
  border: none;
  flex-grow: 1;
  background-color: #fff; /* Fallback for pages that don't load */
}

#browser-frame.iframe-force-dark {
    filter: invert(1) hue-rotate(180deg);
}

#browser-frame.iframe-reader-mode {
    filter: sepia(10%) contrast(110%) brightness(105%);
}


/* --- Tabs Modal Styles --- */
.tabs-box {
  background: rgba(30, 30, 30, 0.85);
  backdrop-filter: blur(10px);
  padding: 20px;
  border-radius: 16px;
  border: .5px solid var(--accent-color);
  max-width: 90vw;
  width: 600px; /* A bit wider for tab titles */
  max-height: 80vh;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
  color: white;
  position: relative;
  animation: fadeIn 0.4s ease;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
}

.tabs-box h2 {
  font-size: 24px;
  font-weight: 700;
  margin-bottom: 16px;
  padding-bottom: 10px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

#tabs-list-container {
  overflow-y: auto;
  flex-grow: 1;
  margin-bottom: 15px;
}

.tabs-footer {
    display: flex;
    justify-content: flex-end;
    padding-top: 10px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    flex-shrink: 0;
}

#close-all-tabs-btn {
    background: transparent;
    border: 1px solid #d9534f;
    color: #d9534f;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.2s ease, color 0.2s ease;
}

#close-all-tabs-btn:hover {
    background-color: #d9534f;
    color: white;
}

.tab-item {
  display: flex;
  align-items: center;
  padding: 12px 8px;
  border-radius: 8px;
  cursor: pointer;
  transition: background-color 0.2s ease;
  text-decoration: none;
  color: white;
}

.tab-item:hover, .tab-item:focus-visible {
  background-color: rgba(255, 255, 255, 0.1);
}

.tab-item img {
  width: 20px;
  height: 20px;
  margin-right: 15px;
  border-radius: 4px;
}

.tab-item-info {
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.tab-item-title {
  font-size: 15px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tab-item-url {
  font-size: 12px;
  color: #aaa;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}


/* --- History Modal Styles --- */
#history-content-box {
    background: rgba(30, 30, 30, 0.85);
    backdrop-filter: blur(10px);
    padding: 20px;
    border-radius: 16px;
    border: .5px solid var(--accent-color);
    max-width: 90vw;
    width: 600px; /* Wider for history */
    max-height: 80vh;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
    font-family: 'Georgia', serif;
    color: white;
    position: relative;
    animation: fadeIn 0.4s ease;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
}

#history-tabs {
    display: flex;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    margin-bottom: 15px;
    flex-shrink: 0;
    flex-wrap: nowrap;
    overflow-x: auto;
    overflow-y: hidden;
    -webkit-overflow-scrolling: touch;
    white-space: nowrap;
    scrollbar-width: none;          /* Firefox */
}
#history-tabs::-webkit-scrollbar{ display:none; }  /* Chrome/Safari */


.history-tab {
    background: none;
    border: none;
    color: white;
    padding: 10px 15px;
    cursor: pointer;
    font-size: 15px;
    opacity: 0.7;
    position: relative;
    transition: opacity 0.2s ease;
/* Make each tab keep its width instead of shrinking away */
    flex: 0 0 auto;
    display: inline-block;
}

.history-tab:hover {
    opacity: 1;
}

.history-tab.active {
    opacity: 1;
    font-weight: bold;
}

.history-tab.active::after {
    content: '';
    position: absolute;
    bottom: -1px;
    left: 0;
    right: 0;
    height: 2px;
    background-color: var(--accent-color);
}

#history-log-container {
    flex-grow: 1;
    overflow-y: auto;
    padding-right: 10px; /* For scrollbar */
    margin-bottom: 15px;
    min-height: 100px; /* Ensure it has some height even when empty */
}

.history-entry {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 5px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    font-size: 14px;
}

.history-entry:last-child {
    border-bottom: none;
}

.history-description {
    flex-grow: 1;
    word-break: break-word;
}

.history-timestamp {
    margin-left: 15px;
    color: #aaa;
    font-size: 12px;
    white-space: nowrap;
    flex-shrink: 0;
}

#history-footer {
    display: flex;
    justify-content: flex-end;
    padding-top: 10px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    flex-shrink: 0;
}

#clear-history-btn {
    background: transparent;
    border: 1px solid #d9534f;
    color: #d9534f;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.2s ease, color 0.2s ease;
}

#clear-history-btn:hover {
    background-color: #d9534f;
    color: white;
}

/* ========== CSS‑only “solo slider” focus ========== */

/* Smooth fade for sidebar children */
#settings-sidebar > *{
  transition: opacity .15s, visibility .15s;
}

/* 1) When ANY slider is being pressed, hide every direct child and also clear the panel's own chrome */
#settings-sidebar:has(.slider-container input[type="range"]:active){
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
  backdrop-filter: none !important;
}

/* Hide all children (text, buttons, etc.) */
#settings-sidebar:has(.slider-container input[type="range"]:active) > *{
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
}

/* 2) …except the slider container that is currently being held */
#settings-sidebar:has(.slider-container input[type="range"]:active)
  > .slider-container:has(input[type="range"]:active){
  opacity: 1 !important;
  visibility: visible !important;
  pointer-events: auto !important;
  position: relative;
  z-index: 9999;
}

/* Make sure the active slider itself is fully visible */
.slider-container input[type="range"]:active{
  opacity: 1;
}

/* Optional: cover tiny glitches when finger leaves the element */
@media (hover: none){
  .slider-container input[type="range"]{ touch-action: pan-x; }
}

/* Hide hover/focus visuals only while .pre-hover is on <body> */
.pre-hover .tile:hover,
.pre-hover .tile:focus-visible{
  background: none !important;
  box-shadow: none !important;
  transform: none !important;
}
/* Hide the 3‑dot menu too while .pre-hover is on */
.pre-hover .tile .menu,
.pre-hover .tile:hover .menu,
.pre-hover .tile:focus-visible .menu{
  opacity:0 !important;
  visibility:hidden !important;
  pointer-events:none !important;
}

/* No transitions/animations during first paint */
body.preload #settings-sidebar,
body.preload #sidebar-overlay,
body.preload #iframe-viewer {
  transition: none !important;
}

/* Force them to their hidden state so no jump */
body.preload #settings-sidebar { transform: translateX(100%) !important; }
body.preload #iframe-viewer   { transform: translateY(100%) !important; }

/* Also keep the specific label visible */
body.sidebar-slider-active #settings-sidebar > .slider-container-active,
body.sidebar-slider-active #settings-sidebar > .slider-container-active *{
  opacity: 1 !important;
  visibility: visible !important;
  pointer-events: auto !important;
}
/* iOS safe‑area padding for the in‑app browser header */
#iframeHeader{
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  /* existing background / height / flex styles remain */

  /* reserve the notch / status‑bar space */
  padding-top: env(safe-area-inset-top);
}

/* keep the iframe itself below the header (height:‑‑header‑‑) */
#iframe-viewer{
  top: calc(var(--header-height) + env(safe-area-inset-top));
}
#iframeHeader   { height: 0px; }
#iframe-viewer  { top: calc(0px + env(safe-area-inset-top)); }


</style>
</head>
<body class="preload" tabindex="-1">

<!-- In-App Browser (iFrame Viewer) -->
<div id="iframe-viewer" class="hidden">
    <div id="iframe-controls">
        <div id="iframe-tab-info">
            <img id="iframe-favicon" src="" alt="favicon" />
            <span id="iframe-title">Loading...</span>
        </div>
        <div id="iframe-buttons">
            <button title="Refresh" onclick="refreshActiveTab()">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
            </button>
            <button title="Go Home" onclick="goHome()">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
            </button>
            <button title="Tabs" onclick="openTabsModal()">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="24" height="24">
                    <path d="M3 5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-4l-3 3-3-3H5a2 2 0 0 1-2-2V5z"/>
                    <path d="M9 3v6m6-6v6"/>
                </svg>
            </button>           
            <button title="Force Dark Mode" onclick="toggleIframeDarkMode()">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 3a9 9 0 1 0 9 9c0-.46-.04-.92-.1-1.36a5.389 5.389 0 0 1-4.4 2.26 5.403 5.403 0 0 1-5.4-5.4c0-1.81 0.88-3.39 2.26-4.4A8.892 8.892 0 0 0 12 3Z"/></svg>
            </button>
            <button title="Reader View" onclick="toggleReaderMode()">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M19.999 21.001H4.999v-2h15v2zm0-4H4.999v-2h15v2zm-15-4H19.999v-2H4.999v2zm15-4H4.999V7h15v2zm0-4H4.999V3h15v2z"/></svg>
            </button>
            <button title="Fullscreen" onclick="maximizeTab()">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
            </button>
            <button title="Close Tab" onclick="closeActiveTab()">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
            </button>
        </div>
    </div>
    <iframe id="browser-frame" sandbox="allow-forms allow-modals allow-pointer-lock allow-popups allow-popups-to-escape-sandbox allow-top-navigation-by-user-activation" allow="fullscreen"></iframe>
</div>

<div class="top-blend"></div>

  <div id="aboutModal" class="modal hidden">
    <div class="about-box">
      <span class="close-icon" onclick="closeAboutModal()">✖</span>
      <h2>🧾 About This Start Page</h2>
      <p>🚀 <strong>Built by TechPreeet</strong> — <em>HomePage-Pro</em></p>
      <p>🛠️ <strong>Open-source on GitHub:</strong><br>
        <a href="https://github.com/TechPreeet/HomePage-Pro" target="_blank" class="cta-link">github.com/TechPreeet/<br>HomePage-Pro</a>
      </p>
      <p>💖 <strong>If you enjoy using it, consider supporting the project:</strong></p>
      <p><a href="https://buymeacoffee.com/techpreeet" target="_blank" class="cta-link">☕ Buy Me a Coffee</a></p>
      <p>🌐 <strong>Made with HTML, CSS, JS – no frameworks, no trackers.</strong></p>
      <p style="margin-top: 20px; font-style: italic; font-size: 17px;">❤️ Made with love, caffeine, and late-night debugging.</p>

      <hr style="margin:16px 0; opacity:.2;">

<h3 style="margin:0 0 8px;">✨ Features</h3>

<p class="tagline">
  🏠 <strong>HomePage‑Pro</strong> is a fully customizable, open‑source browser start page and new‑tab replacement.<br>
  It’s sleek, responsive, and adapts to any device — giving you instant access to your bookmarks, live widgets, smart search, and more, all in one place.
</p>
<p class="tagline-sub">
  Whether you want to streamline your workflow or craft the perfect landing screen every time you open a tab, <strong>HomePage‑Pro</strong> brings <em>power, style, and speed</em> together.
</p>

<ul class="about-features">
  <li>🔍 <strong>Smart Search Bar</strong> — URL detection + voice search</li>
  <li>🧠 <strong>Search Engine Switcher</strong> — Google, DuckDuckGo, Bing, Brave, Perplexity, etc.</li>
  <li>↗️ <strong>“Open in New Tab” Toggle</strong> — works for bookmarks & searches</li>
  <li>📚 <strong>Drag‑and‑Drop Bookmarks</strong> — iOS‑style wiggle edit mode</li>
  <li>🖼️ <strong>Custom Icons & Labels</strong> — edit, delete, copy URL quickly</li>
  <li>📤📥 <strong>Export / Import</strong> — move your setup anywhere</li>
  <li>🎨 <strong>Accent Color, Tile Size, Icon Shape</strong> controls</li>
  <li>🪩 <strong>Glass Mode</strong> & 🌙 <strong>Dark Mode</strong></li>
  <li>🌫️ <strong>Blur / Image / Video Backgrounds</strong></li>
  <li>🕰️ <strong>Clock + Greeting</strong> (12/24h, seconds optional) & optional ☁️ weather</li>
  <li>🪙 <strong>Coin Flip mini-tool</strong></li>
  <li>🔔 <strong>Toast Notifications</strong> for friendly feedback</li>
  <li>📱 <strong>PWA-ready</strong> — installable, full-screen, safe-area aware</li>
  <li>♿ <strong>Accessibility</strong> — keyboard focus, ESC closes modals, etc.</li>
</ul>

    </div>
  </div>

  <!-- Tabs Modal -->
  <div id="tabsModal" class="modal hidden">
    <div class="tabs-box">
      <span class="close-icon" onclick="closeTabsModal()">✖</span>
      <h2>❐ Open Tabs</h2>
      <div id="tabs-list-container">
        <!-- Tab items will be injected here -->
      </div>
      <div class="tabs-footer">
          <button id="close-all-tabs-btn">Close All Tabs</button>
      </div>
    </div>
  </div>

  <!-- History Modal -->
  <div id="historyModal" class="modal hidden">
    <div id="history-content-box">
        <span class="close-icon" onclick="closeHistoryModal()">✖</span>
        <h2>📜 Action History</h2>
        <div id="history-tabs">
            <button class="history-tab active" data-filter="All">All</button>
            <button class="history-tab" data-filter="Bookmark">Bookmarks</button>
            <button class="history-tab" data-filter="Setting">Settings</button>
            <button class="history-tab" data-filter="Search">Searches</button>
            <button class="history-tab" data-filter="Voice">Voice</button>
        </div>
        <div id="history-log-container">
            <!-- History items will be injected here -->
        </div>
        <div id="history-footer">
            <button id="clear-history-btn">Clear History</button>
        </div>
    </div>
  </div>
  
  <div id="toast-notification"></div>

  <div id="coinFlipModal" class="modal hidden" onclick="this.classList.add('hidden')">
    <div class="modal-content" onclick="event.stopPropagation()">
        <span class="close-icon" onclick="document.getElementById('coinFlipModal').classList.add('hidden')">✖</span>
        <h3 id="coinFlipResult">Flipping...</h3>
        <div id="coinContainer" onclick="flipCoin(true)"></div>
    </div>
  </div>

  <video id="videoBg" autoplay muted loop playsinline class="hidden"></video>
 
  <!-- New, sits above wallpaper/video but below everything else -->
<div id="bgBlurLayer"></div>

  <div id="sidebar-toggle-btn" onclick="toggleSidebar()">
      <div class="hamburger-icon">
          <span></span>
          <span></span>
          <span></span>
      </div>
  </div>
  <div id="sidebar-overlay" onclick="toggleSidebar()"></div>

  <div class="container">
    <div id="bookmarksWrapper">
        <div class="spacer"></div>
        <form class="search-bar-form" action="javascript:void(0);" onsubmit="performSearch()">
          <input
            type="search"
            id="searchInput"
            placeholder="Search the web..."
            autocomplete="off"
            spellcheck="false"
            autocorrect="off"
            autocapitalize="off"
            oninput="handleSearchInput()"
          />
          <svg id="micIcon" onclick="startVoiceSearch()" title="Voice Search"
            xmlns="http://www.w3.org/2000/svg"
            height="24" width="24" fill="currentColor">
            <path d="M12 15q-1.25 0-2.125-.875T9 12V6q0-1.25.875-2.125T12 3q1.25 0 2.125.875T15 6v6q0 1.25-.875 2.125T12 15Zm-1 6v-3.1q-2.875-.35-4.438-2.563Q5 13.125 5 10.25h2q0 2.3 1.55 3.875T12 15.7q1.9 0 3.45-1.575Q17 12.55 17 10.25h2q0 2.875-1.562 5.087Q15.875 17.55 13 17.9V21Z"/>
          </svg>
          <svg id="clearIcon" onclick="clearSearch()" title="Clear Search"
            xmlns="http://www.w3.org/2000/svg"
            height="24" width="24" fill="currentColor"
            style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; display: none;">
            <path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
          </svg>
          <div id="searchResults" class="search-results-container"></div>
        </form>
        
        <div id="bookmarkControls">
            <button id="toggleTabsBtn" class="toggle-refresh" aria-label="Show tabs">❐</button>
            <button id="addBookmarkBtn" class="toggle-add" aria-label="Add bookmark">＋</button>
            <button id="toggleBookmarks" class="toggle-arrow" aria-label="Hide bookmarks">▼</button>
            <button id="toggleHistoryBtn" class="toggle-refresh" aria-label="Show history">
                <svg width="32" height="32" viewBox="0 0 21 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M12 4C7.58 4 4 7.58 4 12s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z" fill="currentColor"/>
                  <path d="M13 7h-2v5.414l3.293 3.293 1.414-1.414L13 11.586V7z" fill="currentColor"/>
                </svg>
            </button>
            <button id="refreshBtn" class="toggle-refresh" aria-label="Refresh">⟳</button>
        </div>
        
        <div class="grid" id="bookmarkGrid">
          </div>
    </div>
  </div>

  <div id="bookmarkModal" class="modal hidden">
    <div class="modal-content">
      <span class="close-icon" onclick="closeModal()">✖</span>
      <h3 id="modalTitle">Add Bookmark</h3>
      <input type="text" id="bookmarkName" placeholder="Name">
      <input type="text" id="bookmarkUrl" placeholder="URL">
      <input type="text" id="bookmarkIcon" placeholder="Icon URL (optional)">
      <button onclick="submitBookmark()">Add</button>
      <button id="cancelBtn" onclick="closeModal()">Cancel</button>
    </div>
  </div>

  <div id="settings-sidebar">
    <div id="sidebar-profile-section">
        <div id="sidebar-greeting"></div>
        <div id="sidebar-clock"></div>
        <div id="sidebar-date"></div>
        <div id="sidebar-weatherContainer"></div>
    </div>
    <div class="toolbar-option" id="addBookmarkBtnSidebar" aria-label="Add Bookmark" onclick="addBookmark(); toggleSidebar();" tabindex="0">📝 Add Bookmark</div>
    
    <!-- ─── Search Engine Selector ─── -->
<div
  class="toolbar-option toolbar-option-header"
  id="searchEngineHeader"
  tabindex="0"
  role="button"
>
  <span id="currentSearchEngine">
    <img
      src="https://www.google.com/s2/favicons?sz=64&domain=google.com"
      class="search-engine-icon"
      alt="Google logo"
    />
    <span>Google</span>
  </span>
  <span class="arrow"></span>
</div>

<div class="collapsible-content" id="searchEngineContent">
  <div
    class="toolbar-option search-engine-option"
    data-engine="Google"
    tabindex="0"
    onclick="setSearchEngine('Google')"
  >
    <img
      src="https://www.google.com/s2/favicons?sz=64&domain=google.com"
      class="search-engine-icon"
      alt="Google logo"
    />
    <span>Google</span>
  </div>
  <div
    class="toolbar-option search-engine-option"
    data-engine="DuckDuckGo"
    tabindex="0"
    onclick="setSearchEngine('DuckDuckGo')"
  >
    <img
      src="https://www.google.com/s2/favicons?sz=64&domain=duckduckgo.com"
      class="search-engine-icon"
      alt="DuckDuckGo logo"
    />
    <span>DuckDuckGo</span>
  </div>
  <div
    class="toolbar-option search-engine-option"
    data-engine="Bing"
    tabindex="0"
    onclick="setSearchEngine('Bing')"
  >
    <img
      src="https://www.bing.com/favicon.ico"
      class="search-engine-icon"
      alt="Bing logo"
    />
    <span>Bing</span>
  </div>
  <div
    class="toolbar-option search-engine-option"
    data-engine="Yahoo"
    tabindex="0"
    onclick="setSearchEngine('Yahoo')"
  >
    <img
      src="https://www.google.com/s2/favicons?sz=64&domain=yahoo.com"
      class="search-engine-icon"
      alt="Yahoo logo"
    />
    <span>Yahoo</span>
  </div>
  <div
    class="toolbar-option search-engine-option"
    data-engine="Brave"
    tabindex="0"
    onclick="setSearchEngine('Brave')"
  >
    <img
      src="https://www.google.com/s2/favicons?sz=64&domain=brave.com"
      class="search-engine-icon"
      alt="Brave logo"
    />
    <span>Brave</span>
  </div>
  <div
    class="toolbar-option search-engine-option"
    data-engine="Perplexity"
    tabindex="0"
    onclick="setSearchEngine('Perplexity')"
  >
    <img
      src="https://www.google.com/s2/favicons?sz=64&domain=perplexity.ai"
      class="search-engine-icon"
      alt="Perplexity logo"
    />
    <span>Perplexity</span>
  </div>
</div>


    <div class="toolbar-option toolbar-option-header" id="clockSettingsHeader" tabindex="0">🕰️ Clock & Greeting</div>
    <div class="collapsible-content" id="clockSettingsContent">
        <div class="toolbar-option" aria-label="Toggle Clock Format" onclick="toggleClockFormat()" tabindex="0">🕒 Toggle Clock Format</div>
       
<!-- Show Clock Seconds -->
<label class="toolbar-option">
  ⏱️ Show Clock Seconds
  <div class="switch">
    <input
      type="checkbox"
      id="clockSecondsSwitch"
      onchange="toggleClockSeconds()"
    />
    <span class="slider"></span>
  </div>
</label>
      
<!-- Weather Widget -->
<label class="toolbar-option">
  ☁️ Weather Widget
  <div class="switch">
    <input
      type="checkbox"
      id="weatherSwitch"
      onchange="toggleWeather()"
    />
    <span class="slider"></span>
  </div>
</label>
       
<!-- Greeting -->
<label class="toolbar-option">
  👋 Greeting
  <div class="switch">
    <input
      type="checkbox"
      id="greetingSwitch"
      onchange="toggleGreeting()"
    />
    <span class="slider"></span>
  </div>
</label>
        
        <div class="toolbar-option" onclick="askUserName()" tabindex="0">✏️ Change Name</div>
    </div>

    <div class="toolbar-option" aria-label="Change Background" onclick="document.getElementById('bgInput').click()" tabindex="0">🖼️ Change Background</div>
    <div class="toolbar-option" aria-label="Set Video Background" onclick="document.getElementById('videoInput').click()" tabindex="0">🎥 Set Video Background</div>
    <div class="toolbar-option" aria-label="Remove Wallpaper" onclick="removeWallpaper()" tabindex="0">🚫 Remove Wallpaper</div>
    <input type="file" id="bgInput" accept="image/*,.heic,.heif,.webp,.avif" />
    <input type="file" id="videoInput" accept="video/mp4,video/webm,video/ogg,video/quicktime,.mov,.hevc">
    <!-- Gradient -->
    <div id="gradientSliderContainer" class="slider-container">
  <div class="toolbar-option" id="gradientLabel">Background Color</div>
  <input type="range" id="gradientSlider" min="0" max="18" value="0"
         class="toolbar-option"
         oninput="setGradientBackground(this.value)">
</div>

    <div class="toolbar-option" id="accentColorOption">
        <label for="accentColorPicker">🎨 Accent Color</label>
        <input type="color" id="accentColorPicker" oninput="previewAccentColor(this.value)" onchange="setAccentColor(this.value)">
    </div>
  
<!-- Glass Mode -->
<label class="toolbar-option">
  🪩 Glass Mode
  <div class="switch">
    <input
      type="checkbox"
      id="glassModeSwitch"
      onchange="toggleGlassMode()"
    />
    <span class="slider"></span>
  </div>
</label>
  
<!-- Dark Mode -->
<label class="toolbar-option">
  🌙 Dark Mode
  <div class="switch">
    <input
      type="checkbox"
      id="darkModeSwitch"
      onchange="toggleDarkMode()"
    />
    <span class="slider"></span>
  </div>
</label>

<!-- Background Blur -->
<label class="toolbar-option">
  🌫️ Background Blur
  <div class="switch">
    <input
      type="checkbox"
      id="bgBlurSwitch"
      onchange="toggleBgBlur()"
    />
    <span class="slider"></span>
  </div>
</label>

<!-- Icon style -->
    <div id="iconStyleSliderContainer" class="slider-container">
  <div class="toolbar-option" id="iconStyleLabel">Icon Style</div>
  <input type="range" id="iconStyleSlider" min="0" max="4" value="0"
         class="toolbar-option"
         oninput="setIconStyle(this.value)">
</div>

  
<!-- Bookmark Labels -->
<label class="toolbar-option">
  🏷️ Hide Bookmark Labels
  <div class="switch">
    <input
      type="checkbox"
      id="labelsSwitch"
      onchange="toggleLabels()"
    />
    <span class="slider"></span>
  </div>
</label>
  <!-- Bookmark size -->
    <div id="tileSizeSliderContainer" class="slider-container">
  <div class="toolbar-option" id="tileSizeLabel">Resize Bookmark Tiles</div>
  <input type="range" id="tileSizeSlider" min="40" max="120" value="90"
         class="toolbar-option"
         oninput="setTileSize(this.value)">
</div>

    
<!-- Open Links in New Tab -->
<label class="toolbar-option">
  🔗 Open Links in New Tab
  <div class="switch">
    <input
      type="checkbox"
      id="newTabLinksSwitch"
      onchange="toggleNewTabLinks()"
    />
    <span class="slider"></span>
  </div>
</label>

<!-- In-App Browser Toggle -->
<label class="toolbar-option">
  🌐 Open Links In-App
  <div class="switch">
    <input
      type="checkbox"
      id="inAppBrowserSwitch"
      onchange="toggleInAppBrowser()"
    />
    <span class="slider"></span>
  </div>
</label>

<div class="toolbar-option toolbar-option-header" id="inAppBrowserSettingsHeader" tabindex="0">🛡️ In-App Browser Settings</div>
<div class="collapsible-content" id="inAppBrowserSettingsContent">
    <label class="toolbar-option">
        Block Popups (Experimental)
        <div class="switch">
            <input type="checkbox" id="blockPopupsSwitch" onchange="updateSandboxPermissions()">
            <span class="slider"></span>
        </div>
    </label>
    <p style="font-size: 11px; opacity: 0.7; padding: 0 10px;">Note: Ad & tracker blocking is not possible without a full browser extension.</p>
</div>

    
    <div class="toolbar-option" id="rearrangeBookmarksToggle" onclick="toggleRearrangeMode()" tabindex="0">🔄 Rearrange Bookmarks</div>
    <div class="toolbar-option" aria-label="Export Bookmarks" onclick="exportBookmarks()" tabindex="0">📤 Export Bookmarks</div>
    <div class="toolbar-option" aria-label="Import Bookmarks" onclick="document.getElementById('importInput').click()" tabindex="0">📥 Import Bookmarks</div>
    <div class="toolbar-option" onclick="resetAllSettings()" tabindex="0">🗑️ Reset All Settings</div>
    <div class="toolbar-option" onclick="openAboutModal()" tabindex="0">🧾 About This Page</div>
    <div class="toolbar-option" onclick="flipCoin(); toggleSidebar();" tabindex="0">🪙 Flip a Coin</div>

    <input type="file" id="importInput" accept=".json,application/json,.html,.htm,text/html">
  </div>

  <script>

 const isIOS = /iphone|ipad|ipod/i.test(navigator.userAgent) && !window.MSStream;
  
let _firstBookmarkLoad = true;

// === Debounce timers ===
let _gradLogTimer = null;
let _tileLogTimer = null;

// === In-App Tab Management ===
let inAppTabs = [];
let activeTabId = null;
let useInAppBrowser = localStorage.getItem("useInAppBrowser") === "true";


    /**
     * Logs an action to the user's history in localStorage.
     * @param {string} type - The category of the action (e.g., 'Bookmark', 'Setting', 'Search', 'Voice').
     * @param {string} description - A human-readable description of the action.
     */
    function logHistory(type, description) {
        try {
            let history = JSON.parse(localStorage.getItem('historyLog') || '[]');
            const newEntry = {
                timestamp: new Date().toISOString(),
                type: type,
                description: description
            };
            history.push(newEntry);
            // To prevent the history from growing indefinitely, let's cap it at 200 entries.
            if (history.length > 200) {
                history = history.slice(history.length - 200);
            }
            localStorage.setItem('historyLog', JSON.stringify(history));
        } catch (e) {
            console.error("Failed to log history:", e);
        }
    }


    // Detect “iOS PWA” (installed to Home Screen, running standalone on iPhone/iPad)
      function isIosPwa() {
        return /iphone|ipad|ipod/i.test(navigator.userAgent) &&
          (window.navigator.standalone === true ||
          window.matchMedia('(display-mode: standalone)').matches);
      }

    let rearrangeMode = false;
    let bookmarks = [];
    let glassMode = false;
    let newTabLinks = localStorage.getItem("newTabLinks") === "true";



(function handleShortcutLaunch(){
  const params = new URLSearchParams(location.search);
  if (!params.has('shortcut')) return;

  switch (params.get('shortcut')){
    case 'addmark': /* your existing */ openAddBookmark(); break;
    case 'coin':    flipCoin();                       break;
    case 'voice':   startVoiceSearch();               break;
  }

  // strip the param so refresh doesn’t repeat it
  params.delete('shortcut');
  history.replaceState({}, '', location.pathname + (params.toString() ? '?'+params : ''));
})();




    const gradients = [
        { name: 'Default', value: '' },
        { name: 'Cosmic', value: 'linear-gradient(to right, #1d2b64, #f8cdda)' },
        { name: 'Twilight', value: 'linear-gradient(to right, #ee0979, #ff6a00)' },
        { name: 'Emerald', value: 'linear-gradient(to right, #00c9ff, #92fe9d)' },
        { name: 'Sunrise', value: 'linear-gradient(to right, #ff9966, #ff5e62)' },
        { name: 'Ocean', value: 'linear-gradient(to right, #43cea2, #185a9d)' },
        { name: 'Grapefruit', value: 'linear-gradient(to right, #ffafbd, #ffc3a0)' },
        { name: 'Deep Space', value: 'linear-gradient(to right, #000000, #434343)' },
        { name: 'Mojito', value: 'linear-gradient(to right, #1d976c, #93f9b9)' },
        { name: 'Amethyst', value: 'linear-gradient(to right, #9d50bb, #6e48aa)' },
        { name: 'Midnight', value: 'linear-gradient(to right, #2c3e50, #4ca1af)' },
        { name: 'Pastel', value: 'linear-gradient(to right, #a1c4fd, #c2e9fb)' },
        { name: 'Volcano', value: 'linear-gradient(to right, #f12711, #f5af19)' },
        { name: 'Cloudy Sky', value: 'linear-gradient(to right, #d7d2cc, #304352)' },
        { name: 'Lush', value: 'linear-gradient(to right, #56ab2f, #a8e063)' },
        { name: 'Royal', value: 'linear-gradient(to right, #141e30, #243b55)' },
        { name: 'Mauve', value: 'linear-gradient(to right, #42275a, #734b6d)' },
        { name: 'Cherry', value: 'linear-gradient(to right, #eb3349, #f45c43)' },
        { name: 'Serenity', value: 'linear-gradient(to right, #2980b9, #6dd5fa, #ffffff)' },
    ];

    const searchEngines = {
        'Google': {
            url: 'https://www.google.com/search?igu=1&q=',
            icon: 'https://www.google.com/s2/favicons?sz=64&domain=google.com'
        },
        'DuckDuckGo': {
            url: 'https://duckduckgo.com/?q=',
            icon: 'https://www.google.com/s2/favicons?sz=64&domain=duckduckgo.com'
        },
        'Bing': {
            url: 'https://www.bing.com/search?q=',
            icon: 'https://www.bing.com/favicon.ico'
        },
        'Yahoo': {
            url: 'https://search.yahoo.com/search?p=',
            icon: 'https://www.google.com/s2/favicons?sz=64&domain=yahoo.com'
        },
        'Brave': {
            url: 'https://search.brave.com/search?q=',
            icon: 'https://www.google.com/s2/favicons?sz=64&domain=brave.com'
        },
        'Perplexity': {
            url: 'https://www.perplexity.ai/search?q=',
            icon: 'https://www.google.com/s2/favicons?sz=64&domain=perplexity.ai'
        }
    };




        function showMenuOptions(tile, bookmark, index) {
      document.querySelectorAll(".floating-menu").forEach(m => m.remove());
      const menu = document.createElement("div");
      menu.className = "floating-menu";
      const actions = ["Edit", "Delete", "Share", "Copy URL", "Open in New Tab", "Open in App"];
      const icons = { Edit:"📝", Delete:"🗑️", Share:"🔗", "Copy URL":"📋", "Open in New Tab":"↗️", "Open in App": "🌐" };

      actions.forEach(action => {
        const opt = document.createElement("div");
        opt.innerHTML = `${icons[action]} ${action}`;
        opt.tabIndex = 0;

        opt.onclick = async (e) => {
        e.preventDefault();
        e.stopPropagation();

        if (action === "Delete") {
            menu.remove();
            showToast("Bookmark deleted");
            logHistory('Bookmark', `Deleted bookmark: '${bookmark.name}'`);
            bookmarks.splice(index, 1);
            localStorage.setItem("bookmarks", JSON.stringify(bookmarks));
            loadBookmarks();
            return;
        } else if (action === "Edit") {
            const modal = document.getElementById("bookmarkModal");
            const nameInput = document.getElementById("bookmarkName");
            const urlInput = document.getElementById("bookmarkUrl");
            const iconInput = document.getElementById("bookmarkIcon");
            const modalTitle = document.getElementById("modalTitle");
            modalTitle.textContent = "Edit Bookmark";
            nameInput.value = bookmark.name;
            urlInput.value = bookmark.url;
            iconInput.value = bookmark.icon || "";
            modal.classList.remove("hidden");
            modal.style.display = "flex";
            const submitBtn = modal.querySelector("button:first-of-type");
            submitBtn.textContent = "Save";
            submitBtn.onclick = (e) => {
              e.preventDefault();
              e.stopPropagation();
              const newName = nameInput.value.trim();
              const newURL = urlInput.value.trim();
              const newIcon = iconInput.value.trim();
              if (!newName || !newURL) {
                showToast("Please enter both a name and URL.");
                return;
              }
              logHistory('Bookmark', `Edited bookmark: '${bookmark.name}' to '${newName}'`);
              bookmarks[index] = { name: newName, url: newURL, icon: newIcon };
              localStorage.setItem("bookmarks", JSON.stringify(bookmarks));
              closeModal();
              loadBookmarks();
            };
          } else if (action === "Share") {
              if (navigator.share) {
                  try {
                      await navigator.share({
                          title: bookmark.name,
                          text: `Check out this link: ${bookmark.name}`,
                          url: bookmark.url,
                      });
                      logHistory('Bookmark', `Shared link for '${bookmark.name}'`);
                  } catch (err) {
                      console.error("Share failed:", err.message);
                  }
              } else {
                  showToast("Share not supported on this browser.");
              }
          } else if (action === "Copy URL") {
              copyToClipboard(bookmark.url);
              logHistory('Bookmark', `Copied URL for '${bookmark.name}'`);
          } else if (action === "Open in New Tab") {
              window.open(bookmark.url, '_blank');
              logHistory('Bookmark', `Opened '${bookmark.name}' in new tab`);
          } else if (action === "Open in App") {
              openInAppTab(bookmark.url, bookmark.name);
          }
  
          
          menu.remove();
        };
        menu.appendChild(opt);
      });

      const rect = tile.getBoundingClientRect();
      const menuWidth = 140; 
      const menuHeight = 200;

      const spaceRight = window.innerWidth - rect.right;
      const spaceLeft = rect.left;
      const spaceBelow = window.innerHeight - rect.bottom;

      menu.style.left = spaceRight >= menuWidth || spaceRight >= spaceLeft 
        ? `${rect.right}px` 
        : `${rect.left - menuWidth}px`;

      menu.style.top = spaceBelow >= menuHeight
        ? `${rect.bottom}px`
        : `${rect.top - menuHeight}px`;

      document.body.appendChild(menu);

      setTimeout(() => {
        document.addEventListener("click", function handler(e) {
          if (!menu.contains(e.target)) {
            menu.remove();
          }
        }, { once: true });
      }, 0);
    }

    function toggleRearrangeMode() {
      rearrangeMode = !rearrangeMode;
      localStorage.setItem("rearrangeMode", rearrangeMode);
      logHistory('Setting', `Toggled rearrange mode ${rearrangeMode ? 'ON' : 'OFF'}`);
      toggleSidebar();
      updateRearrangeToggleUI();
      applyRearrangeMode();
    }

    document.addEventListener("click", function (e) {
      const isTileOrSettings = e.target.closest(".tile, .settings-panel, .toolbar-option");
      const searchResults = document.getElementById('searchResults');
      if (!e.target.closest('.search-bar-form') && !e.target.closest('.search-results-container')) {
          searchResults.style.display = 'none';
      }

      if (rearrangeMode && !isTileOrSettings) {
        rearrangeMode = false;
        localStorage.setItem("rearrangeMode", rearrangeMode);
        updateRearrangeToggleUI();
        applyRearrangeMode();
      }
    });

    function updateRearrangeToggleUI() {
      const toggle = document.getElementById("rearrangeBookmarksToggle");
      toggle.textContent = `🔄 Rearrange Bookmarks ${rearrangeMode ? "✅" : "❌"}`;
    }

    function applyRearrangeMode() {
  const grid = document.getElementById("bookmarkGrid");
  const tiles = grid.querySelectorAll('.tile:not(.add-tile)');

  // This logic now applies styles directly to the existing tiles
  // instead of reloading them from scratch.
  if (rearrangeMode) {
    // Entering rearrange mode
    grid.classList.add("rearrange-active");
    tiles.forEach(tile => {
      tile.draggable = true;
      tile.classList.add('rearrange-wiggle');
      const deleteBtn = tile.querySelector('.delete-btn');
      if (deleteBtn) deleteBtn.style.display = 'flex';
    });
  } else {
    // Exiting rearrange mode
    grid.classList.remove("rearrange-active");
    tiles.forEach(tile => {
      tile.draggable = false;
      tile.classList.remove('rearrange-wiggle');
      const deleteBtn = tile.querySelector('.delete-btn');
      if (deleteBtn) deleteBtn.style.display = 'none';
    });
  }
  // By removing the call to loadBookmarks() here, we prevent the reload and fix the animation issue.
}

    let toastTimeout;
    function showToast(message) {
        const toast = document.getElementById('toast-notification');
        toast.innerHTML = `<span>${message}</span>`;
        toast.classList.add('show');

        clearTimeout(toastTimeout);

        toastTimeout = setTimeout(() => {
            toast.classList.remove('show');
        }, 3000);
    }
// Prevents null.textContent crashes
function setTextSafe(id, text) {
  const el = document.getElementById(id);
  if (el) el.textContent = text;
}


    let confirmationToastTimeout;
    function showConfirmationToast(message, onConfirm) {
        const toast = document.getElementById('toast-notification');
        toast.innerHTML = ''; // Clear previous content

        const messageSpan = document.createElement('span');
        messageSpan.textContent = message;
        toast.appendChild(messageSpan);

        const buttonWrapper = document.createElement('div');
        buttonWrapper.style.marginTop = '10px';

        const confirmButton = document.createElement('button');
        confirmButton.textContent = 'Yes, Reset';
        confirmButton.style.marginRight = '10px';
        confirmButton.style.padding = '5px 10px';
        confirmButton.style.border = 'none';
        confirmButton.style.borderRadius = '5px';
        confirmButton.style.cursor = 'pointer';
        confirmButton.style.background = '#ff4d4d';
        confirmButton.style.color = 'white';


        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.padding = '5px 10px';
        cancelButton.style.border = '1px solid #ccc';
        cancelButton.style.borderRadius = '5px';
        cancelButton.style.cursor = 'pointer';
        cancelButton.style.background = 'transparent';
        cancelButton.style.color = 'white';


        confirmButton.onclick = () => {
            onConfirm();
            toast.classList.remove('show');
        };

        cancelButton.onclick = () => {
            toast.classList.remove('show');
        };

        buttonWrapper.appendChild(confirmButton);
        buttonWrapper.appendChild(cancelButton);
        toast.appendChild(buttonWrapper);

        toast.classList.add('show');

        clearTimeout(confirmationToastTimeout);

        confirmationToastTimeout = setTimeout(() => {
            toast.classList.remove('show');
        }, 5000); // 5 seconds to decide
    }

    document.addEventListener("keydown", function(e) {
      if (e.key === "Escape") {
        if (document.fullscreenElement) {
            document.exitFullscreen();
        }
        goHome(); // This will close the iframe viewer if it's open
        closeModal();
        closeAboutModal();
        closeHistoryModal();
        closeTabsModal();
        const sidebar = document.getElementById('settings-sidebar');
        if (sidebar.classList.contains('open')) {
            toggleSidebar();
        }
      }
    });

    function clearSearch() {
      const input = document.getElementById("searchInput");
      input.value = "";
      handleSearchInput();
      input.focus();
    }

    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open("videoBackgroundDB", 2);
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains("videos")) {
            db.createObjectStore("videos", { keyPath: "id" });
          }
        };
        request.onsuccess = (event) => resolve(event.target.result);
        request.onerror = (event) => reject(new Error(`IndexedDB open error: ${event.target.error}`));
      });
    }

    async function storeVideo(file) {
      try {
        if (file.size > 100 * 1024 * 1024) {
          throw new Error("Video file exceeds 100 MB limit.");
        }
        const db = await openDB();
        const CHUNK_SIZE = 10 * 1024 * 1024;
        const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
        const clearTransaction = db.transaction(["videos"], "readwrite");
        const clearStore = clearTransaction.objectStore("videos");
        for (let i = 0; i < 100; i++) {
          clearStore.delete(`backgroundVideo_${i}`);
        }
        await new Promise((resolve, reject) => {
          clearTransaction.oncomplete = resolve;
          clearTransaction.onerror = () => reject(new Error(`Failed to clear old video: ${clearTransaction.error}`));
        });

        for (let i = 0; i < totalChunks; i++) {
          const start = i * CHUNK_SIZE;
          const end = Math.min(start + CHUNK_SIZE, file.size);
          const chunk = file.slice(start, end);
          const chunkData = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject(new Error(`FileReader error for chunk ${i}: ${reader.error}`));
            reader.readAsArrayBuffer(chunk);
          });
          const transaction = db.transaction(["videos"], "readwrite");
          const store = transaction.objectStore("videos");
          await new Promise((resolve, reject) => {
            const putRequest = store.put({
              id: `backgroundVideo_${i}`,
              data: chunkData,
              mimeType: file.type,
              chunkIndex: i,
              totalChunks: totalChunks
            });
            putRequest.onsuccess = resolve;
            putRequest.onerror = () => reject(new Error(`IndexedDB put error for chunk ${i}: ${putRequest.error}`));
          });
        }
        return;
      } catch (error) {
        console.error("IndexedDB store error:", error.message, error.stack);
        showToast(`Failed to store video: ${error.message}.`);
        throw error;
      }
    }

    async function getVideo() {
      try {
        const db = await openDB();
        const transaction = db.transaction(["videos"], "readonly");
        const store = transaction.objectStore("videos");
        const chunks = [];
        let mimeType = "video/mp4";
        let totalChunks = 0;
        for (let i = 0; i < 100; i++) {
          const request = await new Promise((resolve, reject) => {
            const req = store.get(`backgroundVideo_${i}`);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(new Error(`IndexedDB get error for chunk ${i}: ${req.error}`));
          });
          if (!request) break;
          chunks.push(request.data);
          mimeType = request.mimeType || mimeType;
          totalChunks = request.totalChunks || 1;
        }
        if (chunks.length === 0) {
          console.warn("No video data found in IndexedDB");
          return null;
        }
        const combinedData = new Blob(chunks, { type: mimeType });
        return { data: combinedData, mimeType };
      } catch (error) {
        console.error("IndexedDB get error:", error.message, error.stack);
        return null;
      }
    }

    async function promptVideoUrl() {
      const url = prompt("Enter video URL (e.g., from GitHub, .mp4, .webm, or .ogg):");
      if (url && (url.endsWith(".mp4") || url.endsWith(".webm") || url.endsWith(".ogg"))) {
        removeWallpaper(false);
        const videoBg = document.getElementById("videoBg");
        try {
          const response = await fetch(url, { method: "HEAD" });
          if (!response.ok) throw new Error(`Failed to access video URL: ${response.statusText}`);
          videoBg.src = url;
          videoBg.load();
          videoBg.play().catch(error => console.error("Video play error:", error));
          videoBg.classList.remove("hidden");
          document.body.classList.add("video-active");
          document.body.classList.remove("bg-image-active");
          localStorage.setItem("videoUrl", url);
          localStorage.setItem("hasVideo", "true");
          logHistory('Setting', `Set video background from URL`);

          try {
            const db = await openDB();
            const transaction = db.transaction(["videos"], "readwrite");
            const store = transaction.objectStore("videos");
            for (let i = 0; i < 100; i++) {
              store.delete(`backgroundVideo_${i}`);
            }
            await new Promise((resolve, reject) => {
              transaction.oncomplete = resolve;
              transaction.onerror = () => reject(new Error(`Failed to clear IndexedDB: ${transaction.error}`));
            });
          } catch (error) {
            console.error("Error clearing IndexedDB:", error);
          }
        } catch (error) {
          console.error("Video URL error:", error.message, error.stack);
          showToast(`Failed to load video from URL: ${error.message}`);
        }
      } else {
        showToast("Please enter a valid video URL (.mp4, .webm, or .ogg).");
      }
    }
    
    function removeWallpaper(showAlertMsg = true) {
        const videoBg = document.getElementById("videoBg");
        videoBg.src = "";
        videoBg.classList.add("hidden");
        document.body.classList.remove("video-active");
        localStorage.removeItem("hasVideo");
        localStorage.removeItem("videoUrl");

        document.body.style.backgroundImage = '';
        document.body.classList.remove("bg-image-active");
        localStorage.removeItem("bgImage");

        localStorage.setItem("gradientIndex", 0);
        applyGradientBackground(0);
        document.getElementById('gradientSlider').value = 0;

        if(showAlertMsg) {
            showToast("Wallpaper has been removed.");
            logHistory('Setting', 'Removed wallpaper');
        }
    }

    function setGradientBackground(index) {
        const gradientIndex = parseInt(index, 10);
        const gradient = gradients[gradientIndex];
        const label = document.getElementById('gradientLabel');
        
        if (gradient && gradient.value) {
            document.body.style.backgroundImage = gradient.value;
            document.body.classList.remove("bg-image-active", "video-active");
        } else {
            if (!localStorage.getItem('bgImage') && !localStorage.getItem('hasVideo')) {
                document.body.style.backgroundImage = '';
            }
        }
        
        label.textContent = `Background: ${gradient.name}`;
        // Debounce the log: wait 3s after user stops sliding
        clearTimeout(_gradLogTimer);
        _gradLogTimer = setTimeout(() => {
          if (localStorage.getItem("gradientIndex") !== String(gradientIndex)) {
            logHistory('Setting', `Set background to gradient: ${gradient.name}`);
            localStorage.setItem("gradientIndex", gradientIndex);
          }
        }, 3000);


        const slider = document.getElementById('gradientSlider');
        const percentage = (gradients.length <= 1) ? 100 : (gradientIndex / (gradients.length - 1)) * 100;
        slider.style.background = `linear-gradient(to right, var(--accent-color) ${percentage}%, #ffffff ${percentage}%)`;
    }

    function applyGradientBackground(index) {
        const slider = document.getElementById('gradientSlider');
        slider.value = index;
        setGradientBackground(index);
    }
    
    // This function provides the live preview without logging.
    function previewAccentColor(color) {
        document.documentElement.style.setProperty('--accent-color', color);
    }

    // This function saves and logs only the final color choice.
    function setAccentColor(color) {
        localStorage.setItem('accentColor', color);
        logHistory('Setting', `Changed accent color to ${color}`);
    }

    function openAboutModal() {
      toggleSidebar();
      document.getElementById("aboutModal").classList.remove("hidden");
    }

    function closeAboutModal() {
      const modal = document.getElementById("aboutModal");
      modal.classList.add("hidden");
    }

    document.getElementById("aboutModal").addEventListener("click", function(e) {
      if (e.target === this) closeAboutModal();
    });

    function updateClock() {
      const now = new Date();
      let hours = now.getHours();
      let minutes = now.getMinutes().toString().padStart(2, '0');
      let seconds = now.getSeconds().toString().padStart(2, '0');
      let ampm = '';
      if (!is24Hour) {
        ampm = hours >= 12 ? 'PM' : 'AM';
        hours = hours % 12 || 12;
      }
      const hourStr = is24Hour ? hours.toString().padStart(2, '0') : hours.toString();
      let timeHTML = `${hourStr}<span class="colon">:</span>${minutes}`;
      if (showSeconds) {
        timeHTML += `<span class="colon">:</span><span class="seconds">${seconds}</span>`;
      }
      timeHTML += ampm ? `<span class="ampm">${ampm}</span>` : '';
      
      document.getElementById("sidebar-clock").innerHTML = timeHTML;
      document.getElementById("sidebar-date").textContent = now.toLocaleDateString(undefined, {
        weekday: 'short',
        month: 'short',
        day: 'numeric',
        year: 'numeric'
      });
    }

    let is24Hour = localStorage.getItem("clockFormat") !== "12";
    let showSeconds = localStorage.getItem("showSeconds") === "true";

    function toggleClockFormat() {
      is24Hour = !is24Hour;
      localStorage.setItem("clockFormat", is24Hour ? "24" : "12");
      logHistory('Setting', `Set clock format to ${is24Hour ? '24-hour' : '12-hour'}`);
      updateClock();
    }

    function toggleClockSeconds() {
      showSeconds = !showSeconds;
      localStorage.setItem("showSeconds", showSeconds);
      logHistory('Setting', `${showSeconds ? 'Enabled' : 'Disabled'} clock seconds`);
      updateClock();
    }

    function toggleWeather() {
      const current = localStorage.getItem("showWeather") === "true";
      localStorage.setItem("showWeather", !current);
      logHistory('Setting', `${!current ? 'Enabled' : 'Disabled'} weather widget`);
      applyWeatherToggle(!current);
    }

    function applyWeatherToggle(enabled) {
      const container = document.getElementById("sidebar-weatherContainer");
      if (enabled) {
        container.style.display = "block";
        fetchWeather();
      } else {
        container.style.display = "none";
      }
    }

    function getWeatherEmoji(code) {
      const map = {
        0: "☀️", 1: "🌤️", 2: "⛅", 3: "☁️",
        45: "🌫️", 48: "🌫️",
        51: "🌦️", 61: "🌧️", 63: "🌧️", 65: "🌧️",
        71: "❄️", 73: "❄️", 75: "❄️",
        80: "🌧️", 81: "🌧️", 82: "🌧️",
        95: "⛈️", 96: "⛈️", 99: "⛈️"
      };
      return map[code] || "🌡️";
    }

    async function fetchWeather() {
      const container = document.getElementById("sidebar-weatherContainer");
      if (!navigator.geolocation) {
        displayWeatherFallback("Geolocation is not supported.");
        return;
      }
      navigator.geolocation.getCurrentPosition(async (position) => {
        const { latitude, longitude } = position.coords;
        try {
          const url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true`;
          const response = await fetch(url);
          if (!response.ok) {
              throw new Error(`API request failed: ${response.status}`);
          }
          const data = await response.json();
          const weather = data.current_weather;
          const temp = Math.round(weather.temperature);
          const icon = getWeatherEmoji(weather.weathercode);
          const wind = Math.round(weather.windspeed);
          const text = `${icon} ${temp}°C | Wind: ${wind} km/h`;
          container.textContent = text;
        } catch (err) {
          console.error("Weather fetch error:", err);
          displayWeatherFallback("Weather data unavailable.");
        }
      }, (error) => {
          console.error("Geolocation error:", error);
          displayWeatherFallback("Location permission denied.");
      });
    }

    function displayWeatherFallback(message) {
      document.getElementById("sidebar-weatherContainer").textContent = message;
    }

    function toggleGreeting() {
      const current = localStorage.getItem("showGreeting") === "true";
      localStorage.setItem("showGreeting", !current);
      logHistory('Setting', `${!current ? 'Enabled' : 'Disabled'} greeting message`);
      applyGreetingToggle(!current);
    }

    function applyGreetingToggle(enabled) {
      const greeting = document.getElementById("sidebar-greeting");
      if (enabled) {
        let name = localStorage.getItem("profileName");
        if (!name) {
          askUserName();
          return;
        }
        greeting.textContent = generateFriendlyGreeting(name);
        greeting.style.display = "block";
      } else {
        greeting.style.display = "none";
      }
    }

    function askUserName() {
      const name = prompt("What’s your name?");
      if (name) {
        logHistory('Setting', `Changed user name to '${name}'`);
        localStorage.setItem("profileName", name);
        if (localStorage.getItem("showGreeting") === "true") {
            applyGreetingToggle(true);
        }
      }
    }

    function generateFriendlyGreeting(name) {
      const hour = new Date().getHours();
      let message = "";
      if (hour >= 5 && hour < 12) {
        message = `🌞 Good morning, ${name}!`;
      } else if (hour >= 12 && hour < 17) {
        message = `☕ Good afternoon, ${name}!`;
      } else if (hour >= 17 && hour < 21) {
        message = `🌇 Good evening, ${name}!`;
      } else {
        message = `🌙 Good night, ${name}!`;
      }
      return message;
    }

    function toggleLabels() {
      const hiding = document.body.classList.toggle("hide-labels");
      localStorage.setItem("hideLabels", hiding);
      logHistory('Setting', `${hiding ? 'Hid' : 'Showed'} bookmark labels`);
    }

    function toggleNewTabLinks() {
      newTabLinks = !newTabLinks;
      localStorage.setItem('newTabLinks', newTabLinks);
      logHistory('Setting', `Set 'Open Links in New Tab' to ${newTabLinks}`);
    }

    function toggleInAppBrowser() {
        useInAppBrowser = !useInAppBrowser;
        localStorage.setItem('useInAppBrowser', useInAppBrowser);
        logHistory('Setting', `Set 'Open Links In-App' to ${useInAppBrowser}`);
    }


    function updateNewTabLinksOption() {
      // Old text label (may not exist anymore)
      setTextSafe("newTabLinksOption", `🔗 Open Links in New Tab ${newTabLinks ? "✅" : "❌"}`);

      // New switch UI
      const sw = document.getElementById("newTabLinksSwitch");
      if (sw) sw.checked = newTabLinks;
    }

    
    function resetAllSettings() {
      showConfirmationToast("Are you sure you want to reset everything?", () => {
        localStorage.clear();
        location.reload();
      });
    }

    function handleSearchInput() {
        const input = document.getElementById("searchInput");
        const micIcon = document.getElementById("micIcon");
        const clearIcon = document.getElementById("clearIcon");
        const query = input.value.trim().toLowerCase();
        const bookmarksWrapper = document.getElementById('bookmarksWrapper');
        const searchResultsContainer = document.getElementById('searchResults');

        if (query !== "") {
          micIcon.style.display = "none";
          clearIcon.style.display = "block";
        } else {
          micIcon.style.display = "block";
          clearIcon.style.display = "none";
          searchResultsContainer.style.display = 'none';
        }

        const matchingBookmarks = bookmarks.filter(bookmark => {
            const name = bookmark.name.toLowerCase();
            return name.includes(query);
        });
        
        const tiles = document.querySelectorAll(".tile");
        tiles.forEach(tile => {
            const label = tile.querySelector(".bookmark-label");
            const name = label?.innerText.toLowerCase() || "";
            tile.style.display = name.includes(query) ? "" : "none";
        });
        
        if (bookmarksWrapper.classList.contains('collapsed') && query) {
            searchResultsContainer.innerHTML = '';
            if (matchingBookmarks.length > 0) {
                matchingBookmarks.forEach(bookmark => {
                    const item = document.createElement('a');
                    item.href = bookmark.url;
                    item.className = 'search-result-item';
                    item.tabIndex = 0;
                    if (newTabLinks) item.target = "_blank";

                    const img = document.createElement("img");
                    try {
                        img.src = bookmark.icon || `https://www.google.com/s2/favicons?sz=128&domain=${new URL(bookmark.url.startsWith('http') ? bookmark.url : 'https://' + bookmark.url).hostname}`;
                    } catch (e) {
                        img.src = "https://www.google.com/s2/favicons?sz=128&domain=example.com";
                    }

                    const name = document.createElement("span");
                    name.textContent = bookmark.name;

                    item.appendChild(img);
                    item.appendChild(name);
                    searchResultsContainer.appendChild(item);
                });
                searchResultsContainer.style.display = 'block';
            } else {
                searchResultsContainer.style.display = 'none';
            }
        } else {
            searchResultsContainer.style.display = 'none';
        }
      }

    function copyToClipboard(text) {
        if (navigator.clipboard) {
            navigator.clipboard.writeText(text).then(() => {
                showToast("URL copied to clipboard!");
            }).catch(err => {
                console.error('Failed to copy: ', err);
                showToast("Failed to copy URL.");
            });
        } else {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                showToast("URL copied to clipboard!");
            } catch (err) {
                console.error('Fallback failed to copy: ', err);
                showToast("Failed to copy URL.");
            }
            document.body.removeChild(textArea);
        }
    }
    

    function createBookmarkElement(bookmark, index) {
    const a = document.createElement("a");
    a.draggable = rearrangeMode;
    a.href = bookmark.url; 
    a.className = "tile";
    a.dataset.index = index;
    a.tabIndex = 0;
    
    a.style.animationDelay = `${index * 0.03}s`;

    // --- Main Click Handler ---
const handleClick = (e) => {
  if (rearrangeMode) { e.preventDefault(); return; }
  if (!isIOS && e.currentTarget.dataset.skipClick === '1') {
    e.currentTarget.dataset.skipClick = '0';
    return;
  }

  const tile = e.currentTarget;

  /* ►► Decide first, then prevent default only if we’re overriding ◄◄ */
  if (useInAppBrowser) {
    e.preventDefault();
    openInAppTab(bookmark.url, bookmark.name);
  } else if (newTabLinks) {
    e.preventDefault();
    sessionStorage.setItem('hppReloadOnReturn','1');
    window.open(bookmark.url, '_blank', 'noopener');
  } else {
    /* same‑tab navigation – let the browser follow a.href;
       no e.preventDefault() here                           */
  
    logHistory('Bookmark', `Opened '${bookmark.name}'`);
  }

      tile.classList.add('no-hover');
    setTimeout(()=> tile.classList.remove('no-hover'), 100);


  // clear highlight right away
  tile.blur();
  tile.classList.remove('active','selected');
  requestAnimationFrame(() => {
    tile.blur();
    tile.classList.remove('active','selected');
  });
};


    a.addEventListener('click', handleClick);

    if ('ontouchstart' in window) {          /* works on iOS and Android */
  let pressTimer = null;
  let longPressDidOccur = false;
  let savedHref = null;                            /* NEW */

  a.addEventListener('touchstart', (e) => {
    if (rearrangeMode) return;
    longPressDidOccur = false;
    pressTimer = setTimeout(() => {
      longPressDidOccur = true;

      /* --- NEW: disable navigation --- */
      savedHref = a.getAttribute('href');
      a.removeAttribute('href');                   /* stops iOS default tap */

      showMenuOptions(a, bookmark, index);

    }, 500);
  }, { passive: false });

  a.addEventListener('touchmove', () => clearTimeout(pressTimer));

  a.addEventListener('touchend', (e) => { 
    clearTimeout(pressTimer);

    /* If long‑press happened, keep link disabled until after a frame */
    if (longPressDidOccur) {
      e.preventDefault();                          // stop synthetic click
      /* --- NEW: restore href after this event loop --- */
      setTimeout(() => { if (savedHref) a.setAttribute('href', savedHref); }, 0);
    }
  }, { passive: false });
}

    
    a.addEventListener('contextmenu', (e) => { e.preventDefault(); showMenuOptions(a, bookmark, index); });

    a.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
            handleClick(e);
        }
    });

    const img = document.createElement("img");
    try {
        img.src = bookmark.icon || `https://www.google.com/s2/favicons?sz=128&domain=${new URL(bookmark.url.startsWith('http') ? bookmark.url : 'https://' + bookmark.url).hostname}`;
    } catch (e) {
        img.src = "https://www.google.com/s2/favicons?sz=128&domain=example.com";
    }
    img.draggable = false;
    const savedStyle = localStorage.getItem("iconStyle") || "0";
    const iconStyles = ["round", "squircle", "rounded-rect", "tv-rect", "sammy"];
    img.classList.add(iconStyles[parseInt(savedStyle, 10)] || "round");
    
    const name = document.createElement("div");
    name.className = "bookmark-label";
    name.textContent = bookmark.name;
    name.draggable = false;
    
    const menu = document.createElement("div");
    menu.className = "menu";
    menu.textContent = "⋮";
    menu.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        showMenuOptions(a, bookmark, index);
    };

    a.appendChild(menu);
    a.appendChild(img);
    a.appendChild(name);

    const deleteBtn = document.createElement("div");
    deleteBtn.className = "delete-btn";
    deleteBtn.innerHTML = "−";
    deleteBtn.title = "Delete Bookmark";
    deleteBtn.onclick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        logHistory('Bookmark', `Deleted bookmark: '${bookmark.name}'`);
        bookmarks.splice(index, 1);
        localStorage.setItem("bookmarks", JSON.stringify(bookmarks));
        loadBookmarks();
    };
    a.appendChild(deleteBtn);

    if (rearrangeMode) {
        a.classList.add("rearrange-wiggle");
        deleteBtn.style.display = "flex";
    } else {
        deleteBtn.style.display = "none";
    }

    return a;
}


   function loadBookmarks() {
  const grid = document.getElementById("bookmarkGrid");
  bookmarks = JSON.parse(localStorage.getItem("bookmarks") || "[]");
  
  // Clear out the grid
  grid.innerHTML = "";

  // Populate
  bookmarks.forEach((b, i) => {
    const el = createBookmarkElement(b, i);
    grid.appendChild(el);
  });

  // After the very first load, permanently disable CSS animation
  if (_firstBookmarkLoad) {
    _firstBookmarkLoad = false;
  } else {
    grid.classList.add("no-animation");
  }

  // Now do the rest of your setup (tile size, glass mode, etc.)
  const savedSize = localStorage.getItem("tileSize") || 90;
  document.getElementById("tileSizeSlider").value = savedSize;
  setTileSize(savedSize);
  applyGlassMode();
  updateNewTabLinksOption();
}


function enableDragAndDrop() {
  const grid = document.getElementById("bookmarkGrid");
  let dragSrcIndex = null;
  let draggingTile = null;

  grid.addEventListener("dragstart", (e) => {
    if (!rearrangeMode) return e.preventDefault();
    const tile = e.target.closest(".tile:not(.add-tile)");
    if (!tile) return;
    dragSrcIndex = Number(tile.dataset.index);
    draggingTile = tile;
    tile.classList.add("dragging");
    e.dataTransfer.effectAllowed = "move";
    e.dataTransfer.setData("text/plain", dragSrcIndex);
    setTimeout(() => tile.classList.add("drag-ghost"), 0);
  });

  grid.addEventListener("dragend", (e) => {
    if (!draggingTile) return;
    draggingTile.classList.remove("dragging", "drag-ghost");
    draggingTile = null;
  });

  grid.addEventListener("drop", (e) => {
    if (!rearrangeMode || draggingTile) { 
        e.preventDefault();
        const tiles = Array.from(grid.querySelectorAll(".tile:not(.add-tile)"));
        const newOrder = tiles.map(tile => bookmarks[Number(tile.dataset.index)]);
        bookmarks = newOrder;
        localStorage.setItem("bookmarks", JSON.stringify(bookmarks));
        logHistory('Bookmark', 'Reordered bookmarks');
        loadBookmarks();
    }
  });

  let touchDraggingTile = null;
  let scrollInterval = null;

  const stopAutoScroll = () => {
    clearInterval(scrollInterval);
    scrollInterval = null;
  };

  grid.addEventListener('touchstart', (e) => {
    if (!rearrangeMode || e.target.closest('.delete-btn')) return;
    const tile = e.target.closest('.tile:not(.add-tile)');
    if (!tile) return;

    const touchTimer = setTimeout(() => {
        touchDraggingTile = tile;
        touchDraggingTile.classList.add('drag-ghost');
    }, 200);

    const clearTouchTimer = () => clearTimeout(touchTimer);
    grid.addEventListener('touchend', clearTouchTimer, { once: true });
    grid.addEventListener('touchcancel', clearTouchTimer, { once: true });
  }, { passive: true });


  grid.addEventListener('touchmove', (e) => {
    if (!touchDraggingTile) return;
    e.preventDefault(); 

    const clientX = e.touches[0].clientX;
    const clientY = e.touches[0].clientY;

    const viewportHeight = window.innerHeight;
    const scrollZone = 80;
    const scrollSpeed = 15;

    stopAutoScroll();

    if (clientY < scrollZone) {
      scrollInterval = setInterval(() => { window.scrollBy(0, -scrollSpeed); }, 16);
    } else if (clientY > viewportHeight - scrollZone) {
      scrollInterval = setInterval(() => { window.scrollBy(0, scrollSpeed); }, 16);
    }

    touchDraggingTile.style.display = 'none';
    const elementUnder = document.elementFromPoint(clientX, clientY);
    touchDraggingTile.style.display = '';

    const targetTile = elementUnder ? elementUnder.closest('.tile:not(.add-tile)') : null;
    
    if (targetTile && targetTile !== touchDraggingTile) {
        const bounding = targetTile.getBoundingClientRect();
        if (clientY > bounding.top + bounding.height / 2) {
            targetTile.after(touchDraggingTile);
        } else {
            targetTile.before(touchDraggingTile);
        }
    }
  }, { passive: false });


  grid.addEventListener('touchend', (e) => {
    stopAutoScroll();
    if (!touchDraggingTile) return;

    touchDraggingTile.classList.remove('drag-ghost');
    
    const tiles = Array.from(grid.querySelectorAll(".tile:not(.add-tile)"));
    const newOrder = tiles.map(tile => bookmarks[Number(tile.dataset.index)]);
    bookmarks = newOrder;
    localStorage.setItem("bookmarks", JSON.stringify(bookmarks));
    logHistory('Bookmark', 'Reordered bookmarks');
    
    touchDraggingTile = null;
    loadBookmarks();
  });

  grid.addEventListener("dragover", (e) => {
    if (!rearrangeMode) return;
    e.preventDefault();
    const targetTile = e.target.closest(".tile:not(.add-tile)");
    if (!targetTile || !draggingTile || targetTile === draggingTile) return;
    const bounding = targetTile.getBoundingClientRect();
    if (e.clientY > bounding.top + bounding.height / 2) {
        targetTile.after(draggingTile);
    } else {
        targetTile.before(draggingTile);
    }
      });
    }

    function addBookmark() {
      const modal = document.getElementById("bookmarkModal");
      const nameInput = document.getElementById("bookmarkName");
      const urlInput = document.getElementById("bookmarkUrl");
      const iconInput = document.getElementById("bookmarkIcon");
      const modalTitle = document.getElementById("modalTitle");
      const submitBtn = modal.querySelector("button:first-of-type");
      modalTitle.textContent = "Add Bookmark";
      nameInput.value = "";
      urlInput.value = "";
      iconInput.value = "";
      submitBtn.textContent = "Add";
      submitBtn.onclick = submitBookmark;
      modal.classList.remove("hidden");
      modal.style.display = "flex";
      modal.style.opacity = "1";
      nameInput.focus();
    }

    function submitBookmark() {
      const name = document.getElementById("bookmarkName").value.trim();
      let url = document.getElementById("bookmarkUrl").value.trim();
      const icon = document.getElementById("bookmarkIcon").value.trim();
      if (!url || !name) {
        showToast("Please enter both a name and URL.");
        return;
      }
      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        url = 'https://' + url;
      }
      bookmarks.push({ url, name, icon });
      localStorage.setItem("bookmarks", JSON.stringify(bookmarks));
      logHistory('Bookmark', `Added new bookmark: '${name}'`);
      closeModal();
      loadBookmarks();
    }

    function closeModal() {
      const modal = document.getElementById("bookmarkModal");
      modal.classList.add("hidden");
      modal.style.display = "none";
      document.getElementById("bookmarkName").value = "";
      document.getElementById("bookmarkUrl").value = "";
      document.getElementById("bookmarkIcon").value = "";
      document.getElementById("modalTitle").textContent = "Add Bookmark";
      const submitBtn = modal.querySelector("button:first-of-type");
      submitBtn.textContent = "Add";
      submitBtn.onclick = submitBookmark;
    }

    document.getElementById("bookmarkModal").addEventListener("click", function(event) {
      if (event.target === this || event.target.id === "cancelBtn") {
        closeModal();
      }
    });

    document.getElementById("bookmarkIcon").addEventListener("paste", async function (e) {
      const clipboardItems = e.clipboardData.items;
      for (let i = 0; i < clipboardItems.length; i++) {
        const item = clipboardItems[i];
        if (item.type.indexOf("image") !== -1) {
          const blob = item.getAsFile();
          const reader = new FileReader();
          reader.onload = function (event) {
            document.getElementById("bookmarkIcon").value = event.target.result;
          };
          reader.readAsDataURL(blob);
          e.preventDefault();
          break;
        }
      }
    });

    function toggleSidebar() {
      const sidebar = document.getElementById('settings-sidebar');
      const overlay = document.getElementById('sidebar-overlay');
      const toggleBtn = document.getElementById('sidebar-toggle-btn');
      sidebar.classList.toggle('open');
      overlay.classList.toggle('open');
      toggleBtn.classList.toggle('open');

      if (!sidebar.classList.contains('open')) {
          toggleBtn.style.background = 'transparent';
        }
    }

// ── STUB OUT updateThemeColor ──
// All existing calls will safely no‐op, and
// your single <meta name="theme-color" content="…">
// in your HTML will remain untouched.    
    function updateThemeColor() {
      // no‑op stub: do nothing
    }

    function toggleDarkMode() {
      const isChecked = document.getElementById('darkModeSwitch').checked;
      const newDark  = !isChecked;
      localStorage.setItem('dark-mode', newDark);
      logHistory('Setting', `Set dark mode to ${newDark ? 'ON' : 'OFF'}`);
      applyDarkMode(newDark);
    }


    function applyDarkMode(enabled) {
      if (enabled) {
        document.body.classList.add("dark-mode");
        document.documentElement.style.setProperty("--bg-color", "#121212");
        document.documentElement.style.setProperty("--text-color", "#ffffff");
      } else {
        document.body.classList.remove("dark-mode");
        document.documentElement.style.setProperty("--bg-color", "white");
        document.documentElement.style.setProperty("--text-color", "#000000");
      }
    }

    function applyGlassMode() {
      const body = document.body;
      const searchBar = document.querySelector(".search-bar-form");
      const tiles = document.querySelectorAll(".tile:not(.add-tile)");
      if (glassMode) {
        body.classList.add("glass-mode");
        searchBar.classList.add("glass-tile");
        tiles.forEach(tile => tile.classList.add("glass-tile"));
      } else {
        body.classList.remove("glass-mode");
        searchBar.classList.remove("glass-tile");
        tiles.forEach(tile => tile.classList.remove("glass-tile"));
      }
    }

    function toggleGlassMode() {
      glassMode = !glassMode;
      localStorage.setItem("glassMode", glassMode);
      logHistory('Setting', `Set glass mode to ${glassMode ? 'ON' : 'OFF'}`);
      applyGlassMode();
    }

    function toggleBgBlur() {
      const enabled = document.getElementById('bgBlurSwitch').checked;
      localStorage.setItem('bgBlur', enabled);
      logHistory('Setting', `Set background blur to ${enabled ? 'ON' : 'OFF'}`);
      applyBgBlur(enabled);
    }

    function applyBgBlur(enabled) {
      document.body.classList.toggle('bg-blur', enabled);
    }


    let _iconLogTimer = null; // keep this once globally

function setIconStyle(value, skipLog = false) {
  const styles       = ["Round", "Squircle", "Rounded Rectangle", "TV Rectangle", "Sammy"];
  const styleClasses = ["round", "squircle", "rounded-rect", "tv-rect", "sammy"];

  // Clamp & normalize
  let idx = parseInt(value, 10);
  if (isNaN(idx)) idx = 0;
  idx = Math.max(0, Math.min(styles.length - 1, idx));

  const newStyle = styleClasses[idx];

  // Apply live
  document.querySelectorAll(".tile img").forEach(img => {
    img.className = "";
    img.classList.add(newStyle);
  });

  // UI feedback
  const slider = document.getElementById("iconStyleSlider");
  const label  = document.getElementById("iconStyleLabel");
  if (slider) {
    const pct = (idx / (styles.length - 1)) * 100;
    slider.style.background = `linear-gradient(to right, var(--accent-color) ${pct}%, #ffffff ${pct}%)`;
    slider.value = idx; // sync if clamped
  }
  if (label) label.textContent = `Icon Style: ${styles[idx]}`;

  // Save immediately so refresh keeps it
  const vStr = String(idx);
  const prev = localStorage.getItem("iconStyle");
  localStorage.setItem("iconStyle", vStr);

  // Debounce ONLY the log
  if (!skipLog && prev !== vStr) {
    clearTimeout(_iconLogTimer);
    _iconLogTimer = setTimeout(() => {
      logHistory?.("Setting", `Changed icon style to '${styles[idx]}'`, { value: idx });
    }, 2000);
  }
}



    function setTileSize(size) {
      const tiles         = document.querySelectorAll(".tile");
      const grid          = document.querySelector('.grid');
      const slider        = document.getElementById('tileSizeSlider');
      const tileSizeLabel = document.getElementById('tileSizeLabel');
      let width         = parseInt(size);

      tiles.forEach(tile => {
        tile.style.width     = `${width}px`;
        tile.style.fontSize  = `${Math.max(9, Math.min(15, width / 10))}px`;
        const img = tile.querySelector("img");
        if (img) {
          img.style.width  = `${width * 0.8}px`;
          img.style.height = `${width * 0.8}px`;
        }
      });

      const percentage = ((width - 40) / (120 - 40)) * 100;
      slider.style.background = 
        `linear-gradient(to right, var(--accent-color) ${percentage}%, #ffffff ${percentage}%)`;
      slider.value = width;
      setTextSafe("tileSizeLabel", `Resize Bookmark Tiles (${width}px)`);
      const verticalGap = Math.max(4, Math.round(width * 0.1));
      grid.style.rowGap = verticalGap + 'px';
      
      // Debounce tile-size logging
        clearTimeout(_tileLogTimer);
        const pendingWidth = width;
        _tileLogTimer = setTimeout(() => {
          if (localStorage.getItem("tileSize") !== String(pendingWidth)) {
            logHistory('Setting', `Resized tiles to ${pendingWidth}px`);
            localStorage.setItem("tileSize", pendingWidth);
          }
        }, 3000);
      }


    document.getElementById("importInput").addEventListener("change", async function(event) {
      const file = event.target.files[0];
      if (!file) return;

      const text = await file.text();
      let imported = [];

      try {
        if (file.name.match(/\.(html?|htm)$/i) || text.trim().startsWith("<!DOCTYPE")) {
          const dom = new DOMParser().parseFromString(text, "text/html");
          dom.querySelectorAll("a[href]").forEach(a => {
            imported.push({
              name: a.textContent.trim() || a.href,
              url: a.href,
              icon: ""
            });
          });
        }
        else {
          const data = JSON.parse(text);
          if (data.roots && data.roots.bookmarkBar) {
            function recurse(node) {
              if (node.children) {
                node.children.forEach(recurse);
              } else if (node.uri) {
                imported.push({ name: node.title, url: node.uri, icon: "" });
              }
            }
            recurse(data.roots.bookmarkBar);
            recurse(data.roots.other);
            recurse(data.roots.mobile);
          }
          else if (Array.isArray(data)) {
            imported = data.map(b => ({
              name: b.name,
              url: b.url,
              icon: b.icon || ""
            }));
          }
          else {
            throw new Error("Unrecognized JSON format");
          }
        }

        if (imported.length === 0) {
          showToast("No bookmarks found in that file.");
        } else {
          const seen = new Set(bookmarks.map(b => b.url));
          const newCount = imported.filter(b => !seen.has(b.url)).length;
          imported.forEach(b => {
            if (!seen.has(b.url)) bookmarks.push(b);
          });
          localStorage.setItem("bookmarks", JSON.stringify(bookmarks));
          loadBookmarks();
          showToast(`Imported ${newCount} new bookmarks!`);
          if (newCount > 0) {
            logHistory('Bookmark', `Imported ${newCount} bookmarks`);
          }
        }
      } catch (err) {
        console.error("Import failed:", err);
        // Only scare user if literally nothing imported
        if (imported.length === 0) {
          showToast("Failed to import bookmarks: " + err.message);
        }
      } finally {
        event.target.value = "";
      }
    });


    document.getElementById("videoInput").addEventListener("change", async function (event) {
        const file = event.target.files[0];
        if (file && file.type.startsWith("video/")) {
            removeWallpaper(false);
            const videoBg = document.getElementById("videoBg");
            const blobUrl = URL.createObjectURL(file);
            videoBg.src = blobUrl;
            videoBg.load();
            videoBg.play().catch(error => console.error("Video play error:", error));
            videoBg.classList.remove("hidden");
            document.body.classList.add("video-active");
            logHistory('Setting', `Set video background from file: ${file.name}`);
            try {
                await storeVideo(file);
                localStorage.setItem("hasVideo", "true");
            } catch (error) {
                console.error("Failed to store video:", error.message, error.stack);
            }
        }
    });

    function resizeAndStoreImage(file) {
        const MAX_WIDTH = 3840;
        const MAX_HEIGHT = 2160;
        const reader = new FileReader();

        reader.onload = function(e) {
            const img = new Image();
            img.onload = function() {
                let width = img.width;
                let height = img.height;

                if (width > MAX_WIDTH || height > MAX_HEIGHT) {
                    const ratio = Math.min(MAX_WIDTH / width, MAX_HEIGHT / height);
                    width *= ratio;
                    height *= ratio;
                }

                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);

                const dataUrl = canvas.toDataURL(file.type);
                
                document.body.style.backgroundImage = `url('${dataUrl}')`;
                document.body.classList.add("bg-image-active");
                localStorage.setItem("bgImage", dataUrl);
                showToast("Wallpaper set!");
                logHistory('Setting', `Set image background from file: ${file.name}`);
            }
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    document.getElementById("bgInput").addEventListener("change", function(event) {
      const file = event.target.files[0];
      if (file) {
          if (file.size > 25 * 1024 * 1024) {
              showToast("Wallpaper must be under 25MB.");
              return;
          }
          removeWallpaper(false);
          resizeAndStoreImage(file);
    }
    });


    function performSearch(isVoiceSearch = false) {
        const searchInput = document.getElementById("searchInput");
        const query = searchInput.value.trim();
        if (!query) return;

        if (!isVoiceSearch) {
            logHistory('Search', `Searched for: '${query}'`);
        }

        const isFullURL = /^(https?:\/\/)/i.test(query);
        const isDomainURL = /^[^\s]+\.[^\s]{2,}(\/.*)?$/i.test(query);

        const dest = (isFullURL || isDomainURL) 
            ? (isFullURL ? query : `https://${query}`)
            : searchEngines[localStorage.getItem('searchEngine') || 'Google'].url + encodeURIComponent(query);
        
        const title = (isFullURL || isDomainURL) ? dest : `Search: ${query}`;

        if (useInAppBrowser) {
            openInAppTab(dest, title);
        } else {
            window.open(dest, '_blank');
        }
        
        searchInput.value = "";
        handleSearchInput();
    }



    
    function setSearchEngine(name) {
      // 1) Save choice
      const oldEngine = localStorage.getItem('searchEngine') || 'Google';
      if (oldEngine !== name) {
        logHistory('Setting', `Changed search engine to ${name}`);
        localStorage.setItem('searchEngine', name);
      }

      // 2) Icon lookup
      const icons = {
        Google:       'https://www.google.com/s2/favicons?sz=64&domain=google.com',
        DuckDuckGo:   'https://www.google.com/s2/favicons?sz=64&domain=duckduckgo.com',
        Bing:         'https://www.bing.com/favicon.ico',
        Yahoo:        'https://www.google.com/s2/favicons?sz=64&domain=yahoo.com',
        Brave:        'https://www.google.com/s2/favicons?sz=64&domain=brave.com',
        Perplexity:   'https://www.google.com/s2/favicons?sz=64&domain=perplexity.ai'
      };
      const url = icons[name] || icons.Google;

      // 3) Update header
      document.getElementById('currentSearchEngine').innerHTML =
        `<img src="${url}" class="search-engine-icon" alt="${name} logo">
         <span>${name}</span>`;

      // 4) (Optional) update your search‑input placeholder, if you have one
      const input = document.getElementById('searchInput');
      if (input) input.placeholder = `Search ${name}…`;

        // 5) Close the dropdown
      const hdr = document.getElementById('searchEngineHeader');
      const cnt = document.getElementById('searchEngineContent');
      hdr.classList.remove('open');
      cnt.classList.remove('open');
      }



      function flipCoin(isReflip = false) {
        const modal         = document.getElementById('coinFlipModal');
        const resultText    = document.getElementById('coinFlipResult');
        const coinContainer = document.getElementById('coinContainer');

        if (!isReflip) {
            modal.classList.remove('hidden');
            logHistory('Setting', 'Used coin flip tool');
        }
        coinContainer.innerHTML = '';
        resultText.textContent   = 'Flipping...';

        const coin = document.createElement('div');
        coin.className = 'coin';
        const heads = document.createElement('div');
        heads.className   = 'heads';
        heads.textContent = 'H';
        const tails = document.createElement('div');
        tails.className   = 'tails';
        tails.textContent = 'T';
        coin.append(heads, tails);
        coinContainer.appendChild(coin);

        requestAnimationFrame(() => {
          const result        = Math.random() < 0.5 ? 'Heads' : 'Tails';
          const finalRotation = result === 'Heads' ? 1800 : 1980;
          coin.style.transform = `rotateY(${finalRotation}deg)`;

          setTimeout(() => {
            resultText.textContent = `It's ${result}!`;
          }, 2000);
        });
      }

    let recognition = null;
    let handleCancelClick;
    // FIX: Add a timer to automatically stop recognition on pause (for iOS)
    let speechEndTimeout = null;

    function startVoiceSearch() {
      if (!('webkitSpeechRecognition' in window)) {
        showToast("Voice search is not supported.");
        document.getElementById("searchInput").focus();
        return;
      }
      
      if (recognition && recognition._isStarted) {
        recognition.stop();
        return;
      }

      recognition = new webkitSpeechRecognition();
      recognition.lang = "en-US";
      recognition.interimResults = true;
      recognition.continuous = false; // Stop automatically on pause (iOS‑friendly)
     recognition.onspeechend = () => recognition.stop();  // ← here
      recognition.onspeechend = () => recognition.stop();
      const searchInput = document.getElementById("searchInput");
      const micIcon = document.getElementById("micIcon");
      const container = document.querySelector('.container');
      let finalTranscript = "";

      handleCancelClick = function(event) {
        if (!event.target.closest('a, button, input, .menu, .toolbar-option')) {
          if (recognition && recognition._isStarted) {
            recognition.stop();
          }
        }
      };

      recognition.onstart = () => {
        recognition._isStarted = true;
        searchInput.placeholder = "Listening...";
        micIcon.style.color = "red";
        container.addEventListener('click', handleCancelClick);
      };

      recognition.onresult = (event) => {
        let interimTranscript = "";
        finalTranscript = ""; // Reset final transcript each time
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            finalTranscript += transcript;
          } else {
            interimTranscript += transcript;
          }
        }
        searchInput.value = finalTranscript + interimTranscript;
        handleSearchInput();

        
      };

      recognition.onerror = (event) => {
        if (event.error !== "aborted" && event.error !== 'no-speech') {
          showToast("Voice recognition error: " + event.error);
        }
      };

      // 3) the fixed onend:
      recognition.onend = () => {
        recognition._isStarted = false;
        recognition.onspeechend = () => recognition.stop();  // <-- VAD: stop when user stops talking

        // restore placeholder + mic color
        const eng = localStorage.getItem("searchEngine") || "Google";
        searchInput.placeholder = `Search with ${eng}…`;
        micIcon.style.color     = "";
        container.removeEventListener("click", handleCancelClick);

        // if there's text, run performSearch
        if (searchInput.value.trim()) {
          logHistory('Voice', `Voice search for: '${searchInput.value.trim()}'`);
          performSearch(true); // Pass true to indicate it's a voice search

          // then clear the bar
          searchInput.value = "";
          handleSearchInput();
        }
      };

      recognition.start();
    }

    function exportBookmarks() {
      try {
        const bookmarksData = localStorage.getItem("bookmarks");
        if (!bookmarksData || bookmarksData === "[]") {
          showToast("No bookmarks to export.");
          return;
        }
        const blob = new Blob([bookmarksData], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "bookmarks.json";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast("Bookmarks exported successfully!");
        logHistory('Bookmark', 'Exported bookmarks');
      } catch (error) {
        console.error("Export error:", error);
        showToast("Failed to export bookmarks: " + error.message);
      }
    }
    
    async function loadBackgrounds() {
        const bgImage = localStorage.getItem("bgImage");
        const hasVideo = localStorage.getItem("hasVideo") === "true";
        const videoUrl = localStorage.getItem("videoUrl");
        const gradientIndex = parseInt(localStorage.getItem("gradientIndex") || "0", 10);
        const videoBg = document.getElementById("videoBg");

        if (bgImage) {
            document.body.style.backgroundImage = `url('${bgImage}')`;
            document.body.classList.add("bg-image-active");
        } else if (hasVideo) {
            if (videoUrl) {
                try {
                    const response = await fetch(videoUrl, { method: "HEAD" });
                    if (response.ok) {
                        videoBg.src = videoUrl;
                        videoBg.classList.remove("hidden");
                        document.body.classList.add("video-active");
                        videoBg.load();
                        videoBg.play().catch(error => console.error("Video play error on load:", error));
                    } else {
                        localStorage.removeItem("videoUrl");
                        localStorage.removeItem("hasVideo");
                    }
                } catch (error) {
                    console.error("Failed to load video URL on startup:", error.message, error.stack);
                    localStorage.removeItem("videoUrl");
                    localStorage.removeItem("hasVideo");
                }
            } else {
                try {
                    const videoData = await getVideo();
                    if (videoData && videoData.data) {
                        videoBg.src = URL.createObjectURL(videoData.data);
                        videoBg.classList.remove("hidden");
                        document.body.classList.add("video-active");
                        videoBg.load();
                        videoBg.play().catch(error => console.error("Video play error on load:", error));
                    } else {
                        localStorage.removeItem("hasVideo");
                    }
                } catch (error) {
                    localStorage.removeItem("hasVideo");
                }
            }
        } else if (gradientIndex > 0) {
            applyGradientBackground(gradientIndex);
        }
        updateThemeColor(); // Set initial theme color
    }

    function isTouchDevice() {
      return (('ontouchstart' in window) ||
         (navigator.maxTouchPoints > 0) ||
         (navigator.msMaxTouchPoints > 0));
    }

    // --- In-App Browser & Tab Management ---

    function openInAppTab(url, title) {
        const viewer = document.getElementById('iframe-viewer');
        const frame = document.getElementById('browser-frame');
        const titleEl = document.getElementById('iframe-title');
        const faviconEl = document.getElementById('iframe-favicon');

        // Check if this tab is already open
        const existingTab = inAppTabs.find(tab => tab.url === url);
        if (existingTab) {
            switchToTab(existingTab.id);
            return;
        }

        // Create a new tab object
        const newTab = {
            id: Date.now(),
            url: url,
            title: title
        };
        inAppTabs.push(newTab);
        activeTabId = newTab.id;

        // Update UI
        titleEl.textContent = title;
        try {
            faviconEl.src = `https://www.google.com/s2/favicons?sz=64&domain=${new URL(url).hostname}`;
        } catch {
            faviconEl.src = ''; // Default icon
        }
        
        frame.src = url;
        viewer.classList.remove('hidden');
        logHistory('Tab', `Opened tab: '${title}'`);
    }

    function switchToTab(tabId) {
        const tab = inAppTabs.find(t => t.id === tabId);
        if (!tab) return;

        activeTabId = tab.id;
        const viewer = document.getElementById('iframe-viewer');
        const frame = document.getElementById('browser-frame');
        const titleEl = document.getElementById('iframe-title');
        const faviconEl = document.getElementById('iframe-favicon');

        titleEl.textContent = tab.title;
        try {
            faviconEl.src = `https://www.google.com/s2/favicons?sz=64&domain=${new URL(tab.url).hostname}`;
        } catch {
            faviconEl.src = '';
        }

        frame.src = tab.url;
        viewer.classList.remove('hidden');
        closeTabsModal(); // Close the tab list modal after switching
    }

    function closeActiveTab() {
        inAppTabs = inAppTabs.filter(tab => tab.id !== activeTabId);
        if (inAppTabs.length > 0) {
            // Switch to the last opened tab
            switchToTab(inAppTabs[inAppTabs.length - 1].id);
        } else {
            // No tabs left, go home
            goHome();
        }
    }

    function closeAllTabs() {
        if (confirm("Are you sure you want to close all in-app tabs?")) {
            inAppTabs = [];
            goHome();
            closeTabsModal();
            showToast("All in-app tabs closed.");
        }
    }

    function goHome() {
        const viewer = document.getElementById('iframe-viewer');
        const frame = document.getElementById('browser-frame');
        viewer.classList.add('hidden');
        frame.src = 'about:blank'; // Clear the frame to stop any processes
        activeTabId = null;
        if (document.fullscreenElement) {
            document.exitFullscreen();
        }
    }

    function refreshActiveTab() {
        const frame = document.getElementById('browser-frame');
        frame.src = frame.src; // Reloads the iframe
    }

    function maximizeTab() {
        const viewer = document.getElementById('iframe-viewer');
        if (!document.fullscreenElement) {
            viewer.requestFullscreen().catch(err => {
                showToast(`Error: ${err.message}`);
            });
        } else {
            document.exitFullscreen();
        }
    }

    function toggleIframeDarkMode() {
        document.getElementById('browser-frame').classList.toggle('iframe-force-dark');
    }

    function toggleReaderMode() {
        showToast("Reader mode is experimental and may not work on all sites.");
        document.getElementById('browser-frame').classList.toggle('iframe-reader-mode');
    }

    // --- Tabs Modal Functions ---
    function openTabsModal() {
        const modal = document.getElementById("tabsModal");
        modal.classList.remove("hidden");
        renderTabsList();
    }

    function closeTabsModal() {
        const modal = document.getElementById("tabsModal");
        modal.classList.add("hidden");
    }

    function renderTabsList() {
        const container = document.getElementById("tabs-list-container");
        container.innerHTML = ''; // Clear previous list

        if (inAppTabs.length === 0) {
            container.innerHTML = `<p style="text-align: center; opacity: 0.7;">No in-app tabs are open.</p>`;
            return;
        }

        inAppTabs.forEach(tab => {
            const tabElement = document.createElement('div'); // Use div instead of <a>
            tabElement.className = 'tab-item';
            tabElement.title = `Click to switch to ${tab.title}`;
            tabElement.onclick = () => switchToTab(tab.id);
            
            let favIconUrl = '';
            try {
                favIconUrl = `https://www.google.com/s2/favicons?sz=64&domain=${new URL(tab.url).hostname}`;
            } catch {}

            tabElement.innerHTML = `
                <img src="${favIconUrl}" alt="">
                <div class="tab-item-info">
                    <span class="tab-item-title">${tab.title}</span>
                    <span class="tab-item-url">${tab.url}</span>
                </div>
            `;
            container.appendChild(tabElement);
        });
    }

    // --- History Modal Functions ---
    function openHistoryModal() {
        document.getElementById("historyModal").classList.remove("hidden");
        renderHistory(); // Render with default 'All' filter
    }

    function closeHistoryModal() {
        document.getElementById("historyModal").classList.add("hidden");
    }

    function renderHistory(filter = 'All') {
        const container = document.getElementById('history-log-container');
        const history = JSON.parse(localStorage.getItem('historyLog') || '[]');
        container.innerHTML = '';

        const filteredHistory = history.filter(entry => {
            if (filter === 'All') return true;
            return entry.type === filter;
        });

        if (filteredHistory.length === 0) {
            container.innerHTML = `<p style="text-align: center; opacity: 0.7; margin-top: 20px;">No history recorded for this category.</p>`;
            return;
        }

        // Reverse to show most recent first
        filteredHistory.reverse().forEach(entry => {
            const entryDiv = document.createElement('div');
            entryDiv.className = 'history-entry';

            const descriptionSpan = document.createElement('span');
            descriptionSpan.className = 'history-description';
            descriptionSpan.textContent = entry.description;

            const timestampSpan = document.createElement('span');
            timestampSpan.className = 'history-timestamp';
            const date = new Date(entry.timestamp);
            timestampSpan.textContent = date.toLocaleString();
            timestampSpan.title = date.toISOString();

            entryDiv.appendChild(descriptionSpan);
            entryDiv.appendChild(timestampSpan);
            container.appendChild(entryDiv);
        });
    }

    function clearHistory() {
        if (confirm("Are you sure you want to clear all history? This cannot be undone.")) {
            localStorage.removeItem('historyLog');
            renderHistory(); // Re-render to show it's empty
            showToast("History cleared.");
        }
    }

        function updateSandboxPermissions() {
      const blockPopups = document.getElementById('blockPopupsSwitch').checked;
      const frame = document.getElementById('browser-frame');

      let permissions = "allow-forms allow-modals allow-pointer-lock allow-same-origin allow-scripts allow-top-navigation-by-user-activation";
      if (!blockPopups) {
        permissions += " allow-popups allow-popups-to-escape-sandbox";
      }
      frame.sandbox = permissions;

      const changed = localStorage.getItem('blockPopups') !== String(blockPopups);
      localStorage.setItem('blockPopups', blockPopups);
      if (changed) logHistory('Setting', `Block Popups: ${blockPopups}`);
    }


    window.onload = async function() {
      updateClock();
      setInterval(updateClock, 1000);
      glassMode = localStorage.getItem("glassMode") === "true";
      applyGlassMode();

      const savedAccentColor = localStorage.getItem('accentColor') || '#007bff';
      document.documentElement.style.setProperty('--accent-color', savedAccentColor);
      document.getElementById('accentColorPicker').value = savedAccentColor;
      
      const savedSize = localStorage.getItem("tileSize") || 90;
      setTileSize(savedSize);

      const savedIconStyle = localStorage.getItem("iconStyle") || 0;
      document.getElementById('iconStyleSlider').value = savedIconStyle;
      setIconStyle(savedIconStyle);
      
      const savedGradient = localStorage.getItem("gradientIndex") || 0;
      applyGradientBackground(savedGradient);

      await loadBackgrounds(); 
      
      if (localStorage.getItem("minimalistMode") === "true") {
        document.body.classList.add("minimalist");
      }
      
      rearrangeMode = localStorage.getItem("rearrangeMode") === "true";
      updateRearrangeToggleUI();
      applyRearrangeMode();
      
      enableDragAndDrop();
      applyDarkMode(localStorage.getItem("dark-mode") === "true");
      loadBookmarks();
      
if (typeof initSearchEngineSelector === 'function') initSearchEngineSelector();
      
      const mic = document.getElementById("micIcon");
      mic.classList.add("animate-mic");
      setTimeout(() => mic.classList.remove("animate-mic"), 1000);
      if (localStorage.getItem("hideLabels") === "true") {
        document.body.classList.add("hide-labels");
      }
      
      if (!isTouchDevice()) {
        document.getElementById('searchInput').focus();
      }

      document.body.style.pointerEvents = "auto";
    };

    document.addEventListener("contextmenu", function (e) {
      if (rearrangeMode) {
        e.preventDefault();
      }
    });

    // FIX: Refined logic for sidebar button touch state
    document.addEventListener('DOMContentLoaded', () => {
        const sidebarBtn = document.querySelector('#sidebar-toggle-btn');
        if (sidebarBtn) {
            const removeActiveClass = () => {
                sidebarBtn.classList.remove('active-touch');
            };

            sidebarBtn.addEventListener('pointerdown', () => {
                sidebarBtn.classList.add('active-touch');
            });
            sidebarBtn.addEventListener('pointerup', removeActiveClass);
            sidebarBtn.addEventListener('pointerleave', removeActiveClass);
            sidebarBtn.addEventListener('pointercancel', removeActiveClass);
        }
    });

    window.addEventListener('DOMContentLoaded', () => {
      const params = new URLSearchParams(window.location.search);
      const action = params.get('action');
      if (action === 'add') {
          addBookmark();                           
        } else if (action === 'flip') {
          flipCoin();                              
        }
        else if (action === 'voice') {
          startVoiceSearch();
        }
        
        function setupCollapsible(headerId, contentId) {
            const header = document.getElementById(headerId);
            const content = document.getElementById(contentId);
            if (!header || !content) return;
            header.addEventListener('click', () => {
                header.classList.toggle('open');
                content.classList.toggle('open');
            });
            header.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    header.click();
                }
            });
        }
        
        setupCollapsible('clockSettingsHeader', 'clockSettingsContent');
        setupCollapsible('searchEngineHeader', 'searchEngineContent');
        setupCollapsible('inAppBrowserSettingsHeader', 'inAppBrowserSettingsContent');
    });

    window.addEventListener('DOMContentLoaded', () => {
      const saved = localStorage.getItem('searchEngine') || 'Google';
      setSearchEngine(saved);
    });

    window.addEventListener('DOMContentLoaded', () => {
      const savedDark = localStorage.getItem('dark-mode') === 'true';
      // apply whatever you had last
      applyDarkMode(savedDark);
      // but make the toggle CLOSED when dark, OPEN when light
      document.getElementById('darkModeSwitch').checked = !savedDark;
    });


    document.getElementById('refreshBtn').addEventListener('click', () => {
      location.reload();
    });


     document.addEventListener('DOMContentLoaded', () => {
        const wrapper     = document.getElementById('bookmarksWrapper');
        const toggleBtn   = document.getElementById('toggleBookmarks');
        const addBtn      = document.getElementById('addBookmarkBtn');
        const refreshBtn  = document.getElementById('refreshBtn');
        const tabsBtn     = document.getElementById('toggleTabsBtn');
        const historyBtn  = document.getElementById('toggleHistoryBtn');

        // Setup click listeners for new buttons
        tabsBtn.addEventListener('click', openTabsModal);
        historyBtn.addEventListener('click', openHistoryModal);

        // Listeners to close modals by clicking outside
        document.getElementById('tabsModal').addEventListener('click', (e) => {
            if (e.target.id === 'tabsModal') closeTabsModal();
        });
        document.getElementById('close-all-tabs-btn').addEventListener('click', closeAllTabs);
        document.getElementById('historyModal').addEventListener('click', (e) => {
            if (e.target.id === 'historyModal') closeHistoryModal();
        });
        document.getElementById('clear-history-btn').addEventListener('click', clearHistory);
        document.querySelectorAll('.history-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelector('.history-tab.active').classList.remove('active');
                tab.classList.add('active');
                renderHistory(tab.dataset.filter);

        document.querySelector('#history-tabs .history-tab.active')
        ?.scrollIntoView({ inline: 'center', block: 'nearest', behavior: 'smooth' });
            });
        });

        const saved = localStorage.getItem('bookmarksCollapsed') === 'true';
        wrapper.classList.toggle('collapsed', saved);
        
        const isInitiallyCollapsed = wrapper.classList.contains('collapsed');
        const buttonsToToggle = [addBtn, refreshBtn, tabsBtn, historyBtn];
        buttonsToToggle.forEach(btn => {
            if(btn) btn.style.display = isInitiallyCollapsed ? 'none' : '';
        });
        
        toggleBtn.setAttribute('aria-label', isInitiallyCollapsed ? 'Show bookmarks' : 'Hide bookmarks');
        if (isInitiallyCollapsed) {
            toggleBtn.style.transform = 'rotate(-180deg)';
        }

        toggleBtn.addEventListener('click', () => {
            const isCollapsed = wrapper.classList.toggle('collapsed');
            toggleBtn.setAttribute('aria-label', isCollapsed ? 'Show bookmarks' : 'Hide bookmarks');
            toggleBtn.style.transform = isCollapsed ? 'rotate(-180deg)' : '';
            
            buttonsToToggle.forEach(btn => {
                if(btn) btn.style.display = isCollapsed ? 'none' : '';
            });

            if (!isCollapsed) {
                document.getElementById('searchResults').style.display = 'none';
            }
            localStorage.setItem('bookmarksCollapsed', isCollapsed);
            logHistory('Setting', `${isCollapsed ? 'Collapsed' : 'Expanded'} bookmarks section`);
        });

        addBtn.addEventListener('click', () => {
            addBookmark();
        });

        // Samsung-style slider interaction
        document.querySelectorAll('.slider-container input[type="range"]').forEach(slider => {
            const container = slider.parentElement;
            const sidebar = document.getElementById('settings-sidebar');
            slider.addEventListener('touchstart', () => {
                sidebar.classList.add('sidebar-content-hidden');
                container.classList.add('slider-container-active');
            }, { passive: true });
            slider.addEventListener('touchend', () => {
                sidebar.classList.remove('sidebar-content-hidden');
                container.classList.remove('slider-container-active');
            });
        });
    });


    window.addEventListener('DOMContentLoaded', () => {
      // ⏰ Clock & seconds
      updateClock();  
      document.getElementById('clockSecondsSwitch').checked =
        (localStorage.getItem('showSeconds') === 'true');

      // ☁️ Weather
      const weatherOn = localStorage.getItem('showWeather') === 'true';
      document.getElementById('weatherSwitch').checked = weatherOn;
      applyWeatherToggle(weatherOn);

      // 👋 Greeting
      const greetOn = localStorage.getItem('showGreeting') === 'true';
      document.getElementById('greetingSwitch').checked = greetOn;
      applyGreetingToggle(greetOn);

      // 🪩 Glass Mode
      const glassOn = localStorage.getItem('glassMode') === 'true';
      glassMode = glassOn;  // sync the module‑level var
      document.getElementById('glassModeSwitch').checked = glassOn;
      applyGlassMode();

      // 🏷️ Bookmark Labels
      const labelsHidden = localStorage.getItem('hideLabels') === 'true';
      document.getElementById('labelsSwitch').checked = labelsHidden;
      if (labelsHidden) {
        document.body.classList.add('hide-labels');
      } else {
        document.body.classList.remove('hide-labels');
      }

      // 🔗 Open Links in New Tab
      const newTab = localStorage.getItem('newTabLinks') === 'true';
      document.getElementById('newTabLinksSwitch').checked = newTab;
      
      // 🌐 In-App Browser
      const inApp = localStorage.getItem('useInAppBrowser') === 'true';
      document.getElementById('inAppBrowserSwitch').checked = inApp;
      useInAppBrowser = inApp;

      // 🛡️ In-App Browser Settings
      const blockPopups = localStorage.getItem('blockPopups') === 'true';
      document.getElementById('blockPopupsSwitch').checked = blockPopups;
      updateSandboxPermissions();
    });


    document.addEventListener('DOMContentLoaded', () => {
      const blurSaved = localStorage.getItem('bgBlur') === 'true';
      const blurSwitch = document.getElementById('bgBlurSwitch');
      if (blurSwitch) blurSwitch.checked = blurSaved;
      applyBgBlur(blurSaved);
    });

// Mobile/desktop fallback to keep the classes on while dragging
(function(){
  const pairs = [
    ['tileSizeSlider','tileSizeSliderContainer'],
    ['gradientSlider','gradientSliderContainer'],
    ['iconStyleSlider','iconStyleSliderContainer']
  ];
  pairs.forEach(([sid, cid])=>{
    const s = document.getElementById(sid);
    const c = document.getElementById(cid);
    if(!s || !c) return;

    const on  = ()=>{ document.body.classList.add('sidebar-slider-active'); c.classList.add('slider-container-active'); };
    const off = ()=>{ document.body.classList.remove('sidebar-slider-active'); c.classList.remove('slider-container-active'); };

    s.addEventListener('pointerdown', on, {passive:true});
    s.addEventListener('touchstart',  on, {passive:true});
    s.addEventListener('input',       on);        // keeps it active while sliding
    s.addEventListener('pointerup',   off);
    s.addEventListener('touchend',    off);
    s.addEventListener('pointercancel', off);
    s.addEventListener('mouseleave',  off);
  });

  // safety reset
  document.addEventListener('pointerup', ()=>{
    document.body.classList.remove('sidebar-slider-active');
    document.querySelectorAll('.slider-container-active')
      .forEach(el=>el.classList.remove('slider-container-active'));
  }, {passive:true});
})();


// --- Reload home when returning after opening a bookmark in a new tab ---
(function () {
  const RELOAD_KEY = 'hppReloadOnReturn';

  // Set flag when a tile opens in a new tab
  document.addEventListener('click', e=>{
    const tile = e.target.closest('.tile');
    if (!tile) return;
    if (window.newTabLinks) {           // you already use this toggle
      sessionStorage.setItem(RELOAD_KEY, '1');
    }
  }, {capture:true, passive:true});

  // When page becomes visible again, reload once
  document.addEventListener('visibilitychange', ()=>{
    if (!document.hidden && sessionStorage.getItem(RELOAD_KEY) === '1') {
      sessionStorage.removeItem(RELOAD_KEY);
      location.reload();
    }
  });

  // Safety for Android bfcache
  window.addEventListener('pageshow', ()=>{
    if (sessionStorage.getItem(RELOAD_KEY) === '1') {
      sessionStorage.removeItem(RELOAD_KEY);
      location.reload();
    }
  });
})();

// Add .pre-hover whenever we (re)enter the page, remove it on first move
(function(){
  function armFreeze(){
    document.body.classList.add('pre-hover');
    const unfreeze = () => {
      document.body.classList.remove('pre-hover');
      window.removeEventListener('mousemove', unfreeze, {once:true});
      window.removeEventListener('pointermove', unfreeze, {once:true});
    };
    window.addEventListener('mousemove', unfreeze, {once:true});
    window.addEventListener('pointermove', unfreeze, {once:true});
  }
  window.addEventListener('pageshow', armFreeze);  // coming back from new tab / bfcache
  window.addEventListener('focus',    armFreeze);  // plain tab switch
})();


window.addEventListener('load', () => {
  requestAnimationFrame(() => document.body.classList.remove('preload'));
});


// prevent a “click-through” when your custom menu is open
document.addEventListener('click', function(e) {
  if (e.target.closest('.tile') && document.querySelector('.floating-menu')) {
    e.stopImmediatePropagation();  // stop any other click handlers
    e.preventDefault();            // block the navigation
  }
}, true); // use capture phase so it runs before your link’s default click


   // Register SW only when served from http/https (not file://)
    if (
      'serviceWorker' in navigator &&
      (location.protocol === 'https:' || location.protocol === 'http:')
    ) {
      window.addEventListener('load', () => {
        navigator.serviceWorker
          .register('./serviceworker.js', { scope: './' })
          .then(reg => console.log('✅ Service worker registered:', reg.scope))
          .catch(err => console.error('❌ Service worker registration failed:', err));
      });
    } else {
      console.log('Skipping SW registration (protocol:', location.protocol, ')');
    }


    
  </script>
</body>
</html>
